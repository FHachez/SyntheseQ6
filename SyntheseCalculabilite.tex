\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{palatino}
\usepackage{listingsutf8} 
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{tabularx}
\usepackage{tikz}
\usepackage{placeins}

\usepackage[bottom]{footmisc}
\usepackage{desclist}
\usepackage{tocloft}
\setlength\cftparskip{4pt}

\setlist[itemize]{topsep=3pt,after=\vspace{.5\baselineskip}}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\setlength{\parskip}{2mm}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\renewcommand{\stcomp}[1]{\overline{#1}} 

% Modification de 'listing'
\lstset{
  language=Java,						% choose the language of the code
  numbers=left,						% where to put the line-numbers
  stepnumber=1,						% the step between two line-numbers.        
  numbersep=5pt,						% how far the line-numbers are from the code
  backgroundcolor=\color{white},		% choose the background color. You must add \usepackage{color}
  showspaces=false,					% show spaces adding particular underscores
  showstringspaces=false,			% underline spaces within strings
  showtabs=false,					% show tabs within strings adding particular underscores
  tabsize=2,							% sets default tabsize to 2 spaces
  captionpos=b,						% sets the caption-position to bottom
  breaklines=true,					% sets automatic line breaking
  breakatwhitespace=true,			% sets if automatic breaks should only happen at whitespace
  title=\lstname,					% show the filename of files included with \lstinputlisting;
  keywordstyle=\color{blue},			% keyword style
  numberstyle=\tiny\color{mygray},	% the style that is used for the line-numbers
  rulecolor=\color{black},			% the frame-color may be changed on line-breaks within not-black text
  basicstyle=\small\ttfamily,		% text style
  basewidth=0.51em,					% text height
  showstringspaces=false,			% show space
  frame=single,						% type of border
  commentstyle=\color{mygreen},		% comment style
  stringstyle=\color{mymauve},		% string literal style
  tabsize=2,							% sets default tabsize to 2 spaces
  belowskip=-2mm,
}


\def\blurb{\textsc{Université catholique de Louvain\\
  École polytechnique de Louvain}}
\def\clap#1{\hbox to 0pt{\hss #1\hss}}%
\def\ligne#1{%
  \hbox to \hsize{%
    \vbox{\centering #1}}}%
\def\haut#1#2#3{%
  \hbox to \hsize{%
    \rlap{\vtop{\raggedright #1}}%
    \hss
    \clap{\vbox{\vfill\centering #2\vfill}}%
    \hss
    \llap{\vtop{\raggedleft #3}}}}%
\begin{document}

\begin{titlepage}
\thispagestyle{empty}\vbox to 1\vsize{%
  \vss
  \vbox to 1\vsize{%
    \haut{\raisebox{-8mm}{\includegraphics[width=2cm]{logo_ucl.pdf}}}{\blurb}{\raisebox{-3mm}{\includegraphics[scale=0.35]{logo_epl.jpg}}}
    \vfill
    \ligne{\Huge \textbf{\textsc{Synthèse calculabilité}}}
    \vspace{5mm}
    \ligne{\large{-- juin 2014 --}}
    \vfill
    \ligne{%
      \begin{tabular}{c}
        \textsc{Travail du groupe :}
      \end{tabular}}
    \vspace{5mm}
    \ligne{%
         \textsc{Hachez} Floran   7372-11-00 
      }
    }%
  \vss
  }
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}
\label{sec:introduction}

\paragraph{}
\label{par:}
La calculabilité c'est l'étude des limites de l'informatique. Il faut bien 
faire attention à faire la différence entre les limites théoriques et les limites
pratiques. Pour calculabilité, on s'occupe des limites théoriques.
Alors que pour la complexité on s'occupe des limites pratiques, détermine la frontière
entre faisable en pratique et infaisable en pratique.
La question principale de la calculabilité est quels sont les problèmes qui peuvent
être résolus par un programme et lesquels ne peuvent pas.

\paragraph{} Le but est de tracer des frontières entre les programmes calculables,
non calculables et non calculables en pratique.

\paragraph{}
\label{par:}
L'intérêt pratique est qu'on peut donc savoir quand ça ne sert à rien 
de résoudre un problème. De plus, on est conscient de a complexité intrinsèque d'un
problème.
% paragraph  (end)

\subsection{Notion de problème}
\label{subsec:notion_de_probl_me}

\paragraph{}
\label{par:}
Premièrement, on doit parler la notion de problème.
Attention, il ne faut pas confondre un problème avec un programme.
Les caractéristiques sont:

\begin{itemize}
	\item un problème est générique : il s'applique à un ensemble de données.
	\item pour chaque donnée particulière, il existe une réponse.
\end{itemize}
On représente un problème dans le cours par une fonction. Donc dans le cours,
la description d'un problème est équivalente à la description delà fonction.
% paragraph  (end)
% subsection notion_de_probl_me (end)

\subsection{Notion de programme}
\label{ssub:notion_de_programme}

Un programme est une "procédure effective", c'est-à-dire exécutable par une machine.
Il existe plein de formalisme permettant la description de "procédure effective".

% subsection notion_de_programme (end)

\subsection{Résultats principaux}
\label{sub:r_sultat_principaux}

\begin{itemize}
	\item Équivalence des langages de programmation (Complet).
	\item Problème non calculable : Il existe des problèmes qui ne peuvent 
		être résolus par un programme. Ex: détection de virus, équivalence
		de programme,...
	\item Problème intrinsèquement complexe. (Voir complexité) Les problèmes
		qui ont une complexité supérieure ou égale à l'exponentielle. Dans
		ce cas même l'amélioration des ordinateurs n'influence presque pas
		la taille de l'entrée possible.
\end{itemize}

% subsection r_sultat_principaux (end)

\subsection{Détection de Virus}
\label{sub:d_tection_de_virus}
On veut déterminer si un programme P avec une entrée D est nuisible.

Spécification du programme détecteur(P,D):\\
Préconditions : un programme P et une donnée D\\
Postconditions : "Mauvais" si P(D) est nuisible,
		"Bon" sinon

\paragraph{}On va créer un programme drôle(P) et essayer de détecter s’ il est nuisible.

drôle(P) \\
if( détecteur(P,P)="Mauvais" then stop \\
else infecter un autre programme en y insérant P

\paragraph{}
Testons drôle(drôle). \\
drôle(drôle) \\
if( détecteur(drôle, drôle)="Mauvais" then stop \\
else infecter un autre programme en y insérant drôle \\

Si drôle(drôle) est nuisible alors le programme s'arrête or il n'est pas nuisible
puisqu'il n'a infecté aucun programme.\\
Si par contre il n'est pas nuisible alors il va un infecter un autre programme.\\
On a donc une contradiction ce qui implique que le programme drôle ne peut exister,
le programme détecteur non plus.
% paragraph  (end)
% subsection d_tection_de_virus (end)

% section introduction (end)Introduction

\section{Concepts}
\label{sec:concepts}

% Dans cette partie il y a pas moyen de synthétiser beaucoup.

\subsection{Ensembles, langages, relations et fonctions}
\label{sub:ensembles_langages_relations_et_fonctions}

\subsubsection{Ensembles}
\label{ssub:ensembles}
Un ensemble est une collection d'objets, sans répétition, appelés les éléments
de l'ensemble.\\

Notation : 
\begin{itemize}
	\item Ensemble fini : { 0, 1, 2}
	\item Ensemble infini : { 0, 1, 2, ...}
	\item Produit cartésien : A x B
	\item Complément : $\stcomp{A}$
\end{itemize}

% subsubsection ensembles (end)

\subsubsection{Langages}
\label{ssub:Langages}
Notation : 
\begin{itemize}
	\item une chaîne de caractère ou un mot : séquence FINIE de symboles. 
		abceced, 010101101
	\item chaîne de caractères vide : $\epsilon$
	\item un alphabet $\sum$ est un ensemble de symboles. $\sum = {1, 2}$
	\item un langage est un ensemble de mots constitués de symboles d'un alphabet
		donné.
	\item ensemble de tous les mots possible avec $\sum$ : $\sum ^*$
\end{itemize}

% subsubsection Langages (end)

\subsubsection{Relations}
\label{ssub:relations}
Soient A, B des ensembles.
\begin{itemize}
	\item Une relation R sur A, B est un sous-ensemble de A x B. C'est-à-dire
		un ensemble de paires <a,b> avec $a\in A$ $b\in B$.
	\item On peut définir une relation par sa table
	\item On peut écrire <a,b> $\in$ R ou aRb ou R(a,b) 
\end{itemize}

% subsubsection relations (end)

\subsubsection{Fonctions}
\label{ssub:fonctions}
Soient A, B des ensembles.
\begin{itemize}
	\item Une fonction f: A $\rightarrow$ B est une relation telle que a $\in$
	A, il existe au plus un b $\in$ B tel que <a,b> $\in$ f
	\item écrire f(a)=b est équivalent à <a,b> $\in$ f
	\item Si il n'existe pas de b $\in$ B tel que f(a)=b alors f(a) est indéfini,
		f(a) = $\perp$
\end{itemize}

Dans le cours on utilise les propriétés classique: dom(f), image(f), fonction totale,
fonction partielle, fonction surjective, injective et injective. On utilise aussi 
l'extension. \\
f est une extension de g si $\forall x \in A$ : $g(x)\neq \perp \Rightarrow f(x) = g(x)$
Autrement dit, f a la même valeur que g partout où g est définie.

\paragraph{Définition d'une fonction}
\label{par:d_finition_d_une_fonciton}
On définit une fonction par sa table qui peut-être infinie.\\
On peut définir la table de plusieurs façons :
\begin{itemize}
	\item Par un texte fini déterminant sans contradiction ni ambigüité le contenu
		de la table.
	\item Par un algorithme ex : f(x) = $2x^3+5$
	\item Écrire toutes les paires de la relation.
\end{itemize}
Attention, il n'est pas nécessaire de décrire ou de connaître un moyen de la calculer
pour pouvoir la définir. Ex : f(x) = 1 s'il y a de la vie autre part que sur terre,
0 sinon.
% paragraph d_finition_d_une_fonction (end)
% subsubsection fonctions (end)
% subsection ensembles_langages_relations_et_fonctions (end)

\subsection{Ensemble énumérable}
\label{sub:ensemble_num_rables}

Avant de dire ce qu'est un ensemble énumérable, on doit savoir que deux ensembles
ont le même cardinal s’il existe une bijection entre eux.

\paragraph{}
Un ensemble est énumérable ou dénombrable si soir il est fini ou il a le même cardinal que $\mathbb{N}$. \\
Quelques propriétés : 
\begin{itemize}
	\item Tout sous-ensemble d'un ensemble énumérable est énumérable.
	\item L'union et l'intersection de deux ensembles énumérables est énumérable.
	\item L'union d'une infinité d'ensembles énumérables est énumérable. (Facile à
		démontrer voir TP)
\end{itemize}

Quelques ensembles non énumérables : 
\begin{itemize}
	\item L'ensemble R
	\item L'ensemble des sous-ensemble de N
	\item L'ensemble des chaînes infinies de caractère sur un alphabet fini
	\item L'ensemble des fonctions de N dans N (Cas important)
\end{itemize}
% subsection ensemble_num_rables (end)

\subsection{Cantor}
\label{sub:cantor}
On va montrer qu'il existe des ensembles non énumérables. Ex R.
L'idée de la démonstration est de :
\begin{enumerate}
	\item Supposer que l'ensemble est énumérable
 	\item Construire une table contenant une soi-disant énumération
	\item Sélectionner la diagonale et dire qu'on doit l'énumérer
	\item Modifier l'élément égal à la diagonale
	\item Montrer que l'élément n'est pas dans l'énumération => Contradiction
	\item Conclusion l'ensemble est pas énumérable
\end{enumerate}
On montre que quand on essaye d'énumérer on loupe toujours des éléments.

TO DO

% subsection cantor (end)

\subsection{Conclusion}
\label{sub:conclusion}
Les ensembles énumérables sont importants pour la suite du cours et aussi car en 
informatique on ne considère que les ensembles énumérables.
Dans le cours, on va souvent devoir montrer qu'un ensemble est énumérable/non énumérable.
Généralement on va utiliser une des techniques suivantes: 
\begin{itemize}
	\item montrer qu'il y a une bijection avec N ou R
	\item montrer que l'ensemble est fini
	\item utiliser Cantor
	\item écrire un programme qui énumère l'ensemble
\end{itemize}

% subsection conclusion (end)
% section concepts (end)

\section{Résultats fondamentaux}
\label{sec:r_sultats_fondamentaux}

\subsection{Algorithmes et effectivité}
\label{sub:algorithmes_et_effectivit_}
Qu'est-ce qu'un algorithme? C'est une procédure qui peut être appliquée à n'importe
quelles données et qui a pour effet de produire un résultat. C'est un ensemble fini
d'instructions qui peuvent être exécutées. Dans on ne tracasse pas de la taille des données,
des instructions ni de la mémoire disponible, mais les considères comme finies. 

\paragraph{}
Attention, un algorithme n'est pas une fonction, mais ça calcule une fonction.\\
De plus dans le cours on se limite aux fonctions de $N^n$ dans $N$. Car on peut,
montrer que ça revient au même que de considéré de $N^n$ dans $N^n$. On va aussi
utiliser Java comme modèle étant donné que c'est plus facile et qu'on va montrer 
que les modèles complets sont équivalents.

% subsection algorithmes_et_effectivit_ (end)

\subsection{Fonctions calculables, ensembles récrusids et récursivement énumérables}
\label{sub:fonctions_calculables_ensembles_r_crusids_et_r_cursivement_num_rables}

\subsubsection{Fonction calculable}
\label{ssub:fonction_calculable}
Une fonction est calculable s’ il existe un algorithme qui, recevant comme donnée
n'importe quels nombres naturels $X_1$,...$X_n$ fourni (tôt ou tard) comme 
résultat f(x) s’il existe.
\paragraph{} S’il ne se termine pas c'est que $f(x)=\perp$. \\
De plus, il faut faire attention entre ne pas être capable d'écrire un algorithme
et ne pas savoir l'écrire. (Voir exemple TP et cours : rose vert sur Mars ou encore
x occurrences de 5 dans $\pi$.
\paragraph{} Une fonction peut-être totale calculable ou partielle calculable.

% subsubsection fonction_calculable (end)

\subsubsection{Ensemble récursif et récursivement énumérable}
\label{ssub:ensemble_r_cursif_et_r_cursivement_num_rable}
Soit $A\subseteq N$\\
\paragraph{}A est récursif s’ il existe un algorithme qui recevant un $X\in N$, fourni (tôt ou 
tard) comme résultat 1 si $x\in A$, 0 si $x\notin A$.\\
L'algorithme décide si x est dans A ou non.

\paragraph{}A est récursivement énumérable s’ il existe un algorithme qui recevant
un $X\in N$, fourni (tôt ou tard) comme résultat 1 si $x\in A$, ne se termine pas
ou fourni un résultat $\neq1$si $x\notin A$.\\
Le souci c'est que même si l'algorithme permet de dire si x est dans A, si x
n'est pas dans A on ne sait rien dire car on ne peut pas dire à un moment qu'on
arrête l'algorithme. Car c'est possible que x soit dans A et que l'algorithme ne
l'a pas encore déterminé (retourne tôt ou tard !).

\paragraph{Définition importante}
\label{par:d_finition_importante}
Fonction caractéristique de A: \\
$X_A$ : N $\rightarrow$ N tel que \\
$X_A(x)$ = 1 si x $\in$ A
       = 0 si x $\notin$ A %TODO better allign
\\
A est un ensemble récursif ssi $X_A$ est une fonction totale calculable. Ce qui
est évident, ça veut dire qu'il existe une fonction $X_A$ qui décide si n'importe
qu'elle x appartient ou non à A.\\
A est un ensemble récursivement énumérable ssi A = dom(f) et $X_A$ est une 
fonction (totale ou partielle) calculable. En effet, si f(x) est défini alors
x appartient à A.\\
A est un ensemble récursivement énumérable ssi A est vide ou A = image(f) et f
est une fonction totale calculable. Car f est une fonction d'énumération (elle
peut répéter plusieurs fois un élément, mais ce n'est pas gênant).\\
% paragraph d_finition_importante (end)

\paragraph{Propriétés importantes}
\label{par:propri_t_s_importantes}
\begin{itemize}
	\item A récursif $\Rightarrow$ A récursivement énumérable. (Propriété plus
		faible)
	\item A récursif $\Rightarrow$ (N \ A) énumérable.\\ On peut facilement créer
		un programme qui retourne 1 - le programme qui décide A.
	\item A récursivement énumérable et (N \ A) récursivement énumérable 
		$\Rightarrow$ A récursivement énumérable.\\ Il suffit de créer un programme
		qui exécuté un peu du programme qui décide A puis un peu de celui qui
		décide (N \ A). \\Jusqu'au moment ou l'un des programmes retourne une
		réponse.
	\item A fini $\Rightarrow$ A récursif. (Trivial)
	\item (N \ A) fini $\Rightarrow$ A récursif. (Trivial)
\end{itemize}

% paragraph propri_t_s_importantes (end)
% subsubsection ensemble_r_cursif_et_r_cursivement_num_rable (end)
% subsection fonctions_calculables_ensembles_r_crusids_et_r_cursivement_num_rables (end)

\subsection{Thèse de Church-Turing}
\label{sub:th_se_de_church_turing}
Grâce à la définition, on sait montrer qu'une fonction est calculable. Mais comment
montrer qu'une fonction n'est pas calculable? Pour ça on a besoin de définition
couvrant la totalité des fonctions calculables. \\
Une autre question est est-ce que prendre un modèle particulier est restrictif?\\
La thèse de Turing répond à ces questions.
\begin{enumerate}
	\item Aucun modèle de la notion de fonction calculable n'est plus puissant
		que les Machines de Turing \\
		Version moderne : Une fonction est calculable s'il existe un 
		programme d'ordinateur qui calcul cette fonction
	\item Toute fonction calculable est calculable par une machine de Turin.
	\item Toutes les définitions formelles de la calculabilité connues à ce 
		jour sont équivalentes (Théorème, ça a été démontré) (justifie 
		l'utilisation de Java comme modèle)
	\item Toutes les formalisations de la calculabilité établies par la 
		suite seront équivalentes aux définitions connues
\end{enumerate}
1, 2 et 4 sont des thèses universellement reconnues comme vraies.

% subsection th_se_de_church_turing (end)

\subsection{Programmes et fonctions}
\label{sub:programmes_et_fonctions}
Dans le cours on utilise un langage de programmation, Java, comme modèle.
Soit P l'ensemble des programmes Java qui reçoit un ou plusieurs entiers comme 
donnée et qui imprime/retourne un résultat.

\paragraph{} P est un ensemble infini dénombrable (chaîne de caractère d'un 
alphabet fini) récursif (il existe un programme, le compilateur, qui détermine 
si un programme est un programme Java ou non).

\paragraph{} P = $P_0$, $P_1$,... ,$P_k$,... (énumération des programmes Java 
sans répétition). Ce qui implique qu'on peut numéroter les programmes Java.\\
On définit $P_k$ comme le programme k dans P et $\phi^{(n)}_k$ : $N^n 
\rightarrow N$ comme étant la fonction calculée pas $P_k$

\paragraph{} Il existe donc une fonction f : $N\rightarrow P$ telle que :
\begin{itemize}
	\item f(k) = $P_k$
	\item f calculable
	\item k (numéro d'un programme) et $P_k$ sont deux représentations 
		distinctes d'un même objet.
\end{itemize}
% subsection programmes_et_fonctions (end)

\subsection{Existence de fonctions non calculable}
\label{sub:existence_de_fonction_non_calculables}
Il existe beaucoup de fonctions non calculables, car le nombre de fonctions de N 
dans N est non dénombrable (Démo par Cantor lors d'un TP). Or le nombre de 
programmes Java est dénombrable. Donc il y a beaucoup de fonctions qui ne sont 
pas calculables.

\paragraph{} On ne s'intéresse qu'aux fonctions qui sont définies par une table 
finie (on ne sait pas définir les tables infinies). Il en existe une infinité 
dénombrable.

\paragraph{} On va maintenant montrer que ce n'est pas parce qu’une fonction 
est définie par une table finie qu'elle est nécessairement calculable (avec la 
fonction halt qui détermine si un programme se termine ou non).

\subsection{Problème de l'arrêt}
\label{sub:probl_me_de_l_arr_t}

Soit la fonction halt: P x N $\rightarrow$ N telle que \\
\begin{tabular}{cc}
  halt(n, x) = 1 & si $P_n(x)$ se termine \\
  halt(n, x) = 0 & sinon \\
  ou &\\
  halt(n, x) = 1 & si $\phi_n(x)\neq \perp$ \\
  halt(n, x) = 0 & sinon \\
\end{tabular}

halt est une fonction bien définie, totale et sa table est infinie mais décrite 
de manière finie. Or on va montrer que halt n'est pas calculable par 
diagonalisation (comme pour la démonstration de Cantor).\\

TODO \\

\paragraph{Conclusion} Il n'existe pas d'algorithme qui détermine si n'importe 
quel programme $P_n$ se termine ou non. Mais dans certains formalismes qui ne 
sont pas des modèles complets, par exemple un langage qui ne permet de calculer 
que des fonctions totale, halt est calculable (halt retourne toujours 1). \\
De plus, il faut faire attention car ce n'est pas parce que halt n'est pas 
calculable que pour un programme donné k, $halt(k,x)$ est non calculable. Par 
exemple $halt(32,123)$ est une fonction constant donc calculable (ce n'est pas 
pour autant qu'on est capable d'écrire l'algorithme), $halt(32,x)$ ça dépend du 
programme 32, par exemple si celui-ci est constant.

\paragraph{} Cette partie du cours est très importante car on a trouvé un 
"trou dans le mur des fonctions calculables" et on va étendre le trou (métaphore
de Mr Deville). C'est-à-dire que maintenant on va utiliser halt pour montrer 
que d'autres fonctions sont calculables.

\paragraph{} Il existe donc au moins un ensemble non récursif (dans notre 
modèle?)\\
K = 
\begin{tabular}{c}
{n|(n,n)$\in$ HALT}\\
{n| halt(n,n)=1}\\
{n| $P_n(b)$ se termine} \\
\end{tabular}

Où HALT est l'ensemble des programmes k qui se termine pour l'entrée x (HALT = {(n,x)|$P_n(x)$ se 
termine}). Et K est l'ensemble des programmes n qui se termine pour l'entrée n.

\paragraph{Propriétés} \\

\begin{itemize}
	\item  K et HALT ne sont pas récursifs
	\item  Ils sont récursivement énumérables\\
		Car il suffit de lancer le programme et s’il retourne quelque 
		chose il se termine sinon on ne sait pas.
	\item  $\stcomp{HALT}$ n'est pas récursivement énumérable sinon HALT 
		serait récursif.
	\item $\stcomp{K}$ n'est pas récursivement énumérable
\end{itemize}

TODO insérer le schéma sur les fonctions et les ensembles

\paragraph{Ensemble co-récursivement énumérable} est un ensemble dont le 
complément est récursivement énumérable. Par exemple $\stcomp{HALT}$. On peut 
en déduire que si un ensemble est récursivement énumérable et co-récursivement 
énumérable alors il est récursif.


% subsection probl_me_de_l_arr_t (end)


% subsection existence_de_fonction_non_calculables (end)

% section r_sultats_fondamentaux (end)

\end{document}
