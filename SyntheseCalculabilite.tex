\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{palatino}
\usepackage{listingsutf8} 
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{tabularx}
\usepackage{tikz}
\usepackage{placeins}
% Math symbols
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage[bottom]{footmisc}
\usepackage{desclist}
\usepackage{tocloft}
\setlength\cftparskip{4pt}

\setlist[itemize]{topsep=3pt,after=\vspace{.5\baselineskip}}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\setlength{\parskip}{2mm}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\renewcommand{\stcomp}[1]{\overline{#1}} 

% Sets
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rn}{\R^n}
\newcommand{\Rnn}{\R^{n \times n}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\Kn}{\K^n}
\newcommand{\Knn}{\K^{n \times n}}

% Theorem and definitions
\theoremstyle{definition}
\newtheorem{mydef}{Définition}
\newtheorem{mynota}[mydef]{Notation}
\newtheorem{myprop}[mydef]{Propriétés}
\newtheorem{myrem}[mydef]{Remarque}
\newtheorem{myform}[mydef]{Formules}
\newtheorem{mycorr}[mydef]{Corrolaire}
\newtheorem{mytheo}[mydef]{Théorème}
\newtheorem{mylem}[mydef]{Lemme}
\newtheorem{myexem}[mydef]{Exemple}
\newtheorem{myineg}[mydef]{Inégalité}


% Modification de 'listing'
\lstset{
  language=Java,						% choose the language of the code
  numbers=left,						% where to put the line-numbers
  stepnumber=1,						% the step between two line-numbers.        
  numbersep=5pt,						% how far the line-numbers are from the code
  backgroundcolor=\color{white},		% choose the background color. You must add \usepackage{color}
  showspaces=false,					% show spaces adding particular underscores
  showstringspaces=false,			% underline spaces within strings
  showtabs=false,					% show tabs within strings adding particular underscores
  tabsize=2,							% sets default tabsize to 2 spaces
  captionpos=b,						% sets the caption-position to bottom
  breaklines=true,					% sets automatic line breaking
  breakatwhitespace=true,			% sets if automatic breaks should only happen at whitespace
  title=\lstname,					% show the filename of files included with \lstinputlisting;
  keywordstyle=\color{blue},			% keyword style
  numberstyle=\tiny\color{mygray},	% the style that is used for the line-numbers
  rulecolor=\color{black},			% the frame-color may be changed on line-breaks within not-black text
  basicstyle=\small\ttfamily,		% text style
  basewidth=0.51em,					% text height
  showstringspaces=false,			% show space
  frame=single,						% type of border
  commentstyle=\color{mygreen},		% comment style
  stringstyle=\color{mymauve},		% string literal style
  tabsize=2,							% sets default tabsize to 2 spaces
  belowskip=-2mm,
}


\def\blurb{\textsc{Université catholique de Louvain\\
  École polytechnique de Louvain}}
\def\clap#1{\hbox to 0pt{\hss #1\hss}}%
\def\ligne#1{%
  \hbox to \hsize{%
    \vbox{\centering #1}}}%
\def\haut#1#2#3{%
  \hbox to \hsize{%
    \rlap{\vtop{\raggedright #1}}%
    \hss
    \clap{\vbox{\vfill\centering #2\vfill}}%
    \hss
    \llap{\vtop{\raggedleft #3}}}}%
\begin{document}

\begin{titlepage}
\thispagestyle{empty}\vbox to 1\vsize{%
  \vss
  \vbox to 1\vsize{%
    \haut{\raisebox{-8mm}{\includegraphics[width=2cm]{logo_ucl.pdf}}}{\blurb}{\raisebox{-3mm}{\includegraphics[scale=0.35]{logo_epl.jpg}}}
    \vfill
    \ligne{\Huge \textbf{\textsc{Synthèse calculabilité}}}
    \vspace{5mm}
    \ligne{\large{-- juin 2014 --}}
    \vfill
    \ligne{%
      \begin{tabular}{c}
        \textsc{Travail du groupe :}
      \end{tabular}}
    \vspace{5mm}
    \ligne{%
         \textsc{Hachez} Floran   7372-11-00 
      }
    }%
  \vss
  }
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}
\label{sec:introduction}

\paragraph{}
\label{par:}
La calculabilité c'est l'étude des limites de l'informatique. Il faut bien 
faire attention à faire la différence entre les limites théoriques et les limites
pratiques. Pour calculabilité, on s'occupe des limites théoriques.
Alors que pour la complexité on s'occupe des limites pratiques. La complexité
détermine la frontière entre faisable en pratique et infaisable en pratique.
La question principale de la calculabilité est quels sont les problèmes qui peuvent
être résolus par un programme et lesquels ne peuvent pas.

\paragraph{} Le but est donc de tracer des frontières entre les programmes calculables,
non calculables et non calculables en pratique.

\paragraph{}
\label{par:}
Ça nous permet de savoir quand ça ne sert à rien de résoudre un problème.
De plus, on est conscient de sa complexité intrinsèque d'un
problème.
% paragraph  (end)

\subsection{Notion de problème}
\label{subsec:notion_de_probl_me}

\paragraph{}
\label{par:}
Premièrement, on doit parler la notion de problème.
Attention, il ne faut pas confondre un problème avec un programme.
Les caractéristiques d'un problème sont:

\begin{itemize}
	\item un problème est générique : il s'applique à un ensemble de données.
	\item pour chaque donnée particulière, il existe une réponse.
\end{itemize}
On représente un problème dans le cours par une fonction. Donc dans le cours,
la description d'un problème est équivalente à la description d'une fonction.
% paragraph  (end)
% subsection notion_de_probl_me (end)

\subsection{Notion de programme}
\label{ssub:notion_de_programme}

Un programme est une "procédure effective", c'est-à-dire exécutable par une machine.
Il existe plein de formalisme permettant la description de "procédure effective".

% subsection notion_de_programme (end)

\subsection{Résultats principaux}
\label{sub:r_sultat_principaux}

\begin{itemize}
	\item Équivalence des langages de programmation (Complet).
	\item Problème non calculable : Il existe des problèmes qui ne peuvent 
		être résolus par un programme. Ex: détection de virus, équivalence
		de programme,...
	\item Problème intrinsèquement complexe. (Voir complexité) Les problèmes
		qui ont une complexité supérieure ou égale à l'exponentielle. Dans
		ce cas même l'amélioration des ordinateurs n'influence presque pas
		la taille de l'entrée possible.
\end{itemize}

% subsection r_sultat_principaux (end)

\subsection{Détection de Virus}
\label{sub:d_tection_de_virus}
On veut déterminer si un programme P avec une entrée D est nuisible.

Spécification du programme detecteur(P,D):\\
\textbf{Préconditions :} un programme P et une donnée D\\
\textbf{Postconditions :} "Mauvais" si P(D) est nuisible,
		"Bon" sinon

\paragraph{}On va créer un programme drole(P) et essayer de détecter s’ il est nuisible.

\begin{lstlisting}
drole(P) \\
if detecteur(P,P) = "Mauvais" 
	then stop
else infecter un autre programme en y inserant P
\end{lstlisting}

Testons drole(drole).
\begin{lstlisting}
drole(drole)
if detecteur(drole, drole) = "Mauvais" 
	then stop
else infecter un autre programme en y inserant drole

\end{lstlisting}

\begin{itemize}
	\item Si drole(drole) est nuisible alors le programme s'arrête or il
	       	n'est pas nuisible puisqu'il n'a infecté aucun programme.
	\item Si par contre il n'est pas nuisible alors il va un infecter un 
		autre programme.
\end{itemize}
On a donc une contradiction ce qui implique que le programme drole ne peut 
exister, ce qui implique que  le programme détecteur non plus.
% paragraph  (end)
% subsection d_tection_de_virus (end)

% section introduction (end)Introduction

\section{Concepts}
\label{sec:concepts}

% Dans cette partie il y a pas moyen de synthétiser beaucoup.

\subsection{Ensembles, langages, relations et fonctions}
\label{sub:ensembles_langages_relations_et_fonctions}

\subsubsection{Ensembles}
\label{ssub:ensembles}
Un ensemble est une collection d'objets, sans répétition, appelés les éléments
de l'ensemble.\\

Notation : 
\begin{itemize}
	\item Ensemble fini : { 0, 1, 2}
	\item Ensemble infini : { 0, 1, 2, ...}
	\item Produit cartésien : A x B
	\item Complément : $\stcomp{A}$
\end{itemize}

% subsubsection ensembles (end)

\subsubsection{Langages}
\label{ssub:Langages}
Notation : 
\begin{itemize}
	\item une chaîne de caractère ou un mot : séquence FINIE de symboles. 
		abceced, 010101101
	\item chaîne de caractères vide : $\epsilon$
	\item un alphabet $\sum$ est un ensemble de symboles. $\sum = {1, 2}$
	\item un langage est un ensemble de mots constitués de symboles d'un alphabet
		donné.
	\item ensemble de tous les mots possible avec $\sum$ : $\sum ^*$
\end{itemize}

% subsubsection Langages (end)

\subsubsection{Relations}
\label{ssub:relations}
Soient A, B des ensembles.
\begin{itemize}
	\item Une relation R sur A, B est un sous-ensemble de A x B. C'est-à-dire
		un ensemble de paires <a,b> avec $a\in A$ $b\in B$.
	\item On peut définir une relation par sa table
	\item On peut écrire <a,b> $\in$ R ou aRb ou R(a,b) 
\end{itemize}

% subsubsection relations (end)

\subsubsection{Fonctions}
\label{ssub:fonctions}
Soient A, B des ensembles.
\begin{itemize}
	\item Une fonction f: A $\rightarrow$ B est une relation telle que a $\in$
	A, il existe au plus un b $\in$ B tel que <a,b> $\in$ f
	\item écrire f(a)=b est équivalent à <a,b> $\in$ f
	\item Si il n'existe pas de b $\in$ B tel que f(a)=b alors f(a) est indéfini,
		f(a) = $\perp$
\end{itemize}

Dans le cours on utilise les propriétés classiques: dom(f), image(f), fonction totale,
fonction partielle, fonction surjective, injective et injective. Celles-ci ne 
seront pas redéfinies ici.\\
On utilise aussi l'\textbf{extension} : 
f est une extension de g si $\forall x \in A$ : $g(x)\neq \perp \Rightarrow f(x) = g(x)$
Autrement dit, f a la même valeur que g partout où g est définie.

\paragraph{Définition d'une fonction}
\label{par:d_finition_d_une_fonciton}
On définit une fonction par sa table qui peut-être infinie.\\
On peut définir la table de plusieurs façons :
\begin{itemize}
	\item Par un texte fini déterminant sans contradiction ni ambigüité le contenu
		de la table.
	\item Par un algorithme ex : f(x) = $2x^3+5$
	\item Écrire toutes les paires de la relation.
\end{itemize}
Attention, il n'est pas nécessaire de décrire ou de connaître un moyen de la calculer
pour pouvoir la définir. Ex : f(x) = 1 s'il y a de la vie autre part que sur terre,
0 sinon.
% paragraph d_finition_d_une_fonction (end)
% subsubsection fonctions (end)
% subsection ensembles_langages_relations_et_fonctions (end)

\subsection{Ensemble énumérable}
\label{sub:ensemble_num_rables}

Avant de dire ce qu'est un ensemble énumérable, on doit savoir que deux ensembles
ont le même cardinal s’il existe une bijection entre eux.

\paragraph{}
Un ensemble est énumérable ou dénombrable si soit il est fini ou il a le même cardinal que $\mathbb{\N}$. \\
Quelques propriétés : 
\begin{myprop}
	Tout sous-ensemble d'un ensemble énumérable est énumérable.
\end{myprop}

\begin{myprop}
L'union et l'intersection de deux ensembles énumérables sont énumérables.
\end{myprop}

\begin{myprop}
L'union d'une infinité d'ensembles énumérables est énumérable. (Facile à
		démontrer voir TP)
\end{myprop}

Quelques ensembles non énumérables : 
\begin{myexem}
 L'ensemble $\R$
\end{myexem}

\begin{myexem}
 L'ensemble des sous-ensembles de $\N$
\end{myexem}

\begin{myexem}
 L'ensemble des chaînes infinies de caractère sur un alphabet fini
\end{myexem}

\begin{myexem}
 L'ensemble des fonctions de $\N$ dans $\N$ (Cas important)
\end{myexem}

% subsection ensemble_num_rables (end)

\subsection{Cantor}
\label{sub:cantor}
On va montrer qu'il existe des ensembles non énumérables. Ex $\R$.
L'idée de la démonstration est de :
\begin{enumerate}
	\item Supposer que l'ensemble est énumérable
 	\item Construire une table contenant une soi-disant énumération
	\item Sélectionner la diagonale et dire qu'on doit l'énumérer
	\item Modifier l'élément égal à la diagonale
	\item Montrer que l'élément n'est pas dans l'énumération => Contradiction
	\item Conclusion l'ensemble est pas énumérable
\end{enumerate}
On montre que quand on essaye d'énumérer on loupe toujours des éléments.

TO DO

% subsection cantor (end)

\subsection{Conclusion}
\label{sub:conclusion}
Les ensembles énumérables sont importants pour la suite du cours et aussi, car en 
informatique on ne considère que les ensembles énumérables.
Dans le cours, on va souvent devoir montrer qu'un ensemble est énumérable/non énumérable.
Généralement on va utiliser une des techniques suivantes: 
\begin{itemize}
	\item montrer qu'il y a une bijection avec $\N$ ou $\R$
	\item montrer que l'ensemble est fini
	\item utiliser la diagonalisation (cf. Cantor)
	\item écrire un programme qui énumère l'ensemble
\end{itemize}

% subsection conclusion (end)
% section concepts (end)

\section{Résultats fondamentaux}
\label{sec:r_sultats_fondamentaux}

\subsection{Algorithmes et effectivité}
\label{sub:algorithmes_et_effectivit_}
Qu'est-ce qu'un algorithme? C'est une procédure qui peut être appliquée à n'importe
quelles données et qui a pour effet de produire un résultat. C'est un ensemble fini
d'instructions qui peuvent être exécutées. Dans ce cours, on ne tracasse pas 
de la taille des données, des instructions ni de la mémoire disponible, mais 
les considères comme finies. 

\begin{myrem}
	Un algorithme n'est pas une fonction, mais un algorithme calcule une 
	fonction.
	De plus dans le cours on se limite aux fonctions de $\N^n$ dans $\N$. Car on peut,
	montrer que ça revient au même que de considéré de $\N^n$ dans $\N^n$ (
	$\N^n$ est énumérable et donc au plus de même cardinal que $\N$). On va aussi
	utiliser Java comme modèle étant donné que c'est plus facile et qu'on va montrer 
	que les modèles complets sont équivalents.
\end{myrem}

% subsection algorithmes_et_effectivit_ (end)

\subsection{Fonctions calculables, ensembles récursifs et récursivement énumérables}
\label{sub:fonctions_calculables_ensembles_r_crusids_et_r_cursivement_num_rables}

\subsubsection{Fonction calculable}
\label{ssub:fonction_calculable}
Une fonction est calculable s’ il existe un algorithme qui, recevant comme donnée
n'importe quels nombres naturels $X_1$,...$X_n$ fourni \textbf{tôt ou tard} comme 
résultat f(x) s’il existe.
\paragraph{} S’il ne se termine pas c'est que $f(x)=\perp$. \\

\begin{myrem}
	De plus, il faut faire attention entre ne pas être capable d'écrire un algorithme
	et ne pas savoir l'écrire. (Voir exemple TP et cours : rose vert sur Mars ou encore
	x occurrences de 5 dans $\pi$.
\end{myrem}

\begin{myrem}
	Une fonction peut-être totale calculable ou partielle calculable.
\end{myrem}

% subsubsection fonction_calculable (end)

\subsubsection{Ensemble récursif et récursivement énumérable}
\label{ssub:ensemble_r_cursif_et_r_cursivement_num_rable}
Soit $A\subseteq \N$

\begin{mydef}
	A est récursif s’ il existe un algorithme qui recevant un $X\in \N$
	, fourni \textbf{tôt ou tard} comme résultat 
	\begin{tabular}{l}
		1 si $x\in A$\\
		0 si $x\notin A$\\
	\end{tabular}
	. L'algorithme décide si x est dans A ou non.
\end{mydef}

\begin{mydef}
	A est récursivement énumérable s’ il existe un algorithme qui recevant
	un $X\in \N$, fourni \textbf{tôt ou tard} comme résultat
	\begin{tabular}{l}
		1 si $x\in A$\\
		 ne se termine pas ou retourne un résultat $\neq1$ si
		 $x\notin A$\\
	\end{tabular}
\end{mydef}

\begin{myrem}
		Le souci c'est que même si l'algorithme permet de dire si x est dans A, si x
		n'est pas dans A on ne sait rien dire, car on ne peut pas dire à un moment qu'on
		arrête l'algorithme. Car c'est possible que x soit dans A et que l'algorithme ne
		l'a pas encore déterminé (retourne tôt ou tard !).
\end{myrem}

\paragraph{Définition importante :}
\label{par:d_finition_importante}

\begin{mydef}
	Fonction caractéristique de A:
	$X_A$ : $\N$ $\rightarrow$ $\N$ tel que $X_A(x)$ =
\begin{tabular}{l}
	1 si x $\in$ A \\	
	0 si x $\notin$ A 
\end{tabular}
\end{mydef}

\begin{mydef}
	A est un ensemble récursif ssi $X_A$ est une fonction totale calculable. Ce qui
	est évident, ça veut dire qu'il existe une fonction $X_A$ qui décide si n'importe
	qu'elle x appartient ou non à A.\\
\end{mydef}

\begin{mydef}
	A est un ensemble récursivement énumérable ssi A = dom(f) et $X_A$ est une 
	fonction (totale ou partielle) calculable. En effet, si f(x) est défini alors
	x appartient à A.\\
\end{mydef}

\begin{mydef}
	A est un ensemble récursivement énumérable ssi A est vide ou A = image(f) et f
	est une fonction totale calculable. Car f est une fonction d'énumération (elle
	peut répéter plusieurs fois un élément, mais ce n'est pas gênant).\\
\end{mydef}

% paragraph d_finition_importante (end)

\paragraph{Propriétés importantes}
\label{par:propri_t_s_importantes}
\begin{myprop}
	A récursif $\Rightarrow$ A récursivement énumérable. (Propriété plus
		faible)
\end{myprop}

\begin{myprop}
	A récursif $\Rightarrow$ ($\N$ \ A) énumérable.\\ On peut facilement créer
		un programme qui retourne 1 - le programme qui décide A.
\end{myprop}

\begin{myprop}
	A récursivement énumérable et ($\N$ \ A) récursivement énumérable 
		$\Rightarrow$ A récursivement énumérable.\\ Il suffit de créer un programme
		qui exécuté un peu du programme qui décide A puis un peu de celui qui
		décide ($\N$ \ A). \\Jusqu'au moment ou l'un des programmes retourne une
		réponse.
\end{myprop}

\begin{myprop}
	A fini $\Rightarrow$ A récursif. (Trivial)
\end{myprop}

\begin{myprop}
	($\N$ \ A) fini $\Rightarrow$ A récursif. (Trivial)
\end{myprop}


% paragraph propri_t_s_importantes (end)
% subsubsection ensemble_r_cursif_et_r_cursivement_num_rable (end)
% subsection fonctions_calculables_ensembles_r_crusids_et_r_cursivement_num_rables (end)

\subsection{Thèse de Church-Turing}
\label{sub:th_se_de_church_turing}
Grâce à la définition, on sait montrer qu'une fonction est calculable. Mais comment
montrer qu'une fonction n'est pas calculable? Pour ça on a besoin d'une définition
couvrant la totalité des fonctions calculables. \\
Une autre question est est-ce que prendre un modèle particulier est restrictif?\\
La thèse de Turing répond à ces questions.
\begin{enumerate}
	\item Aucun modèle de la notion de fonction calculable n'est plus puissant
		que les Machines de Turing \\
		Version moderne : Une fonction est calculable s'il existe un 
		programme d'ordinateur qui calcul cette fonction
	\item Toute fonction calculable est calculable par une machine de Turin.
	\item Toutes les définitions formelles de la calculabilité connues à ce 
		jour sont équivalentes (Théorème, ça a été démontré) (justifie 
		l'utilisation de Java comme modèle)
	\item Toutes les formalisations de la calculabilité établies par la 
		suite seront équivalentes aux définitions connues
\end{enumerate}
1, 2 et 4 sont des thèses universellement reconnues comme vraies.

% subsection th_se_de_church_turing (end)

\subsection{Programmes et fonctions}
\label{sub:programmes_et_fonctions}
Dans le cours on utilise un langage de programmation, Java, comme modèle.

\begin{mydef}
	Soit P l'ensemble des programmes Java qui reçoit un ou plusieurs entiers comme 
	donnée et qui imprime/retourne un résultat.
\end{mydef}

\begin{myprop}
	P est un ensemble infini dénombrable (chaîne de caractère d'un 
	alphabet fini) récursif (il existe un programme, le compilateur, qui détermine 
	si un programme est un programme Java ou non).
\end{myprop}

\begin{mydef}
	P = $P_0$, $P_1$,... ,$P_k$,... (énumération des programmes Java 
	sans répétition). Ce qui implique qu'on peut numéroter les programmes Java.\\
\end{mydef}

\begin{mydef}
	$P_k$ est le programme k dans P et $\phi^{(n)}_k$ : $\N^n 
	\rightarrow \N$ comme étant la fonction calculée pas $P_k$
\end{mydef}


\begin{myprop}
	Il existe donc une fonction f : $\N\rightarrow P$ telle que :
	\begin{itemize}
		\item f(k) = $P_k$
		\item f calculable
		\item k (numéro d'un programme) et $P_k$ sont deux représentations 
			distinctes d'un même objet.
	\end{itemize}
\end{myprop}

% subsection programmes_et_fonctions (end)

\subsection{Existence de fonctions non calculable}
\label{sub:existence_de_fonction_non_calculables}
Il existe beaucoup de fonctions non calculables, car le nombre de fonctions de $\N$ 
dans $\N$ est non dénombrable (Démo par Cantor lors d'un TP). Or le nombre de 
programmes Java est dénombrable. Donc il y a beaucoup de fonctions qui ne sont 
pas calculables.

\paragraph{} On va s'intéresser qu'aux fonctions qui sont définies par une table 
finie (on ne sait pas définir les tables infinies). Il en existe une infinité 
dénombrable.

\paragraph{} On va maintenant montrer que ce n'est pas parce qu’une fonction 
est définie par une table finie qu'elle est nécessairement calculable (avec la 
fonction halt qui détermine si un programme se termine ou non).

% subsection existence_de_fonction_non_calculables (end)

\subsection{Problème de l'arrêt}
\label{sub:probl_me_de_l_arr_t}

Soit la fonction halt: P x $\N$ $\rightarrow$ $\N$ telle que \\
\begin{tabular}{rl}
  halt(n, x) = 1 & si $P_n(x)$ se termine \\
  halt(n, x) = 0 & sinon \\
  ou &\\
  halt(n, x) = 1 & si $\phi_n(x)\neq \perp$ \\
  halt(n, x) = 0 & sinon \\
\end{tabular}

\begin{myprop}
	halt est une fonction bien définie, totale et sa table est infinie, mais décrite 
	de manière finie. Or on va montrer que halt n'est pas calculable par 
	diagonalisation (comme pour la démonstration de Cantor).\\
\end{myprop}

TODO \\

\paragraph{Conclusion} Il n'existe pas d'algorithme qui détermine si n'importe 
quel programme $P_n$ se termine ou non. Mais dans certains formalismes qui ne 
sont pas des modèles complets. Par exemple un langage qui ne permet de calculer 
que des fonctions totale (exemple java sans aucune boucle)
, halt est calculable (halt retourne toujours 1). \\

De plus, il faut faire attention, car ce n'est pas parce que halt n'est pas 
calculable que pour un programme donné k, $halt(k,x)$ est non calculable. Par 
exemple $halt(32,123)$ est une fonction constant donc calculable (ce n'est pas 
pour autant qu'on est capable d'écrire l'algorithme), $halt(32,x)$ peut-être 
calculable mais ça dépend du 
programme 32, par exemple si celui-ci est constant.

\begin{myrem}
	Cette partie du cours est très importante, car on a trouvé un 
	"trou dans le mur des fonctions calculables" et on va étendre le trou (métaphore
	de Mr Deville). C'est-à-dire que maintenant on va utiliser halt pour montrer 
	que d'autres fonctions sont calculables/non calculable. (par exemple 
	par réduction, en effet, si on peut calculer halt grâce à une fonction 
	alors celle-ci n'est pas calculable.
\end{myrem}

Il existe donc au moins un ensemble non récursif (dans notre 
modèle?)\\
K = 
\begin{tabular}{l}
	\{n|(n,n)$\in$ HALT\}\\
	\{n| halt(n,n)=1\}\\
	\{n| $P_n(b)$ se termine\} \\
\end{tabular}

Où HALT est l'ensemble des programmes k qui se termine pour l'entrée x, 
HALT = {(n,x)|$P_n(x)$ se termine}). Et K est l'ensemble des programmes n qui
se termine pour l'entrée n.

\begin{myprop}
	K et HALT ne sont pas récursifs
\end{myprop}
	
\begin{myprop}
	K et HALT sont récursivement énumérables (car il suffit de lancer le 
	programme et s’il retourne quelque chose il se termine sinon on ne sait 
	pas)
\end{myprop}
	
\begin{myprop}
	$\stcomp{HALT}$ n'est pas récursivement énumérable sinon HALT 
		serait récursif.
\end{myprop}
	
\begin{myprop}
	$\stcomp{K}$ n'est pas récursivement énumérable
\end{myprop}
	

TODO insérer le schéma sur les fonctions et les ensembles

\begin{mydef}
	\textbf{Un ensemble co-récursivement énumérable} est un ensemble dont le 
	complément est récursivement énumérable. Par exemple $\stcomp{HALT}$. On peut 
	en déduire que si un ensemble est récursivement énumérable et co-récursivement 
	énumérable alors il est récursif.
\end{mydef}

% subsection probl_me_de_l_arr_t (end)

\subsection{Insuffisance des fonctions totales}
\label{sub:insuffisance_des_fonctions_totales}
Comme on a vu qu'il était possible de calculer halt dans un modèle qui
permet de calculer que des fonctions totales, on se pose la question de 
pourquoi on n'utilise pas un tel modèle. De plus les fonctions "pratiques" sont 
des fonctions totales. Mais on va montrer qu'un tel modèle nous restreint 
beaucoup sur ce qu'on peut calculer.

\begin{myexem}
	Un tel modèle est par exemple Java, mais sans boucle 
	donc par intuition on se doute qu'il y a beaucoup de choses qu'on ne peut pas 
	calculer.
\end{myexem}

\begin{mydef}
	Posons Q un langage dont tous les programmes se terminent et pour 
	lequel il existe un interpréteur calculable, interpret(n,x)=$\phi'_n$. Où
	$\phi'_k$ est la fonction calculée par le programme $Q_k$. L'interpréteur est une 
	fonction totale.
\end{mydef}

\begin{mytheo}
	\label{Hoare_Allison}
	\textbf{Hoare-Allison :}
	interpret(n,x) n'est pas calculable dans Q.\\
	TODO démonstration par diagonalisation
\end{mytheo}



\subsubsection{Implication du théorème \ref{Hoare_Allison} }

\begin{myprop}
	Si un langage ne permet que le calcul de fonction total alors :
	\begin{itemize}
		\item l'interpréteur de ce langage n'est pas calculable dans ce langage
		\item il existe des fonctions totales non programmables dans ce langage
		\item ce langage est \bf{restrictif}
	\end{itemize}
\end{myprop}
	
\begin{myprop}
	Si un langage permet de programmer son propre interpréteur alors il ne permet 
	pas de programmer la fonction halt de ce langage.
\end{myprop}

\begin{myprop}
	Dans un langage de programmation, il est donc impossible que 
	l'interpréteur et la fonction halt (de ce langage) puissent être programmés dans ce langage.
\end{myprop}

\begin{myprop}
	Si on veut pouvoir programmer toutes les fonctions 
	totales dans un langage, le langage doit permettre la programmation de 
	fonctions non totales.
\end{myprop}

\begin{myprop}
	L'ensemble {n| $\phi_n$ est totale} n'est pas récursif. (sinon on 
	saurait créer un langage qui ne calcule que des fonctions totales??)
\end{myprop}

TODO insérer la fonction universelle ???

% subsection insuffisance_des_fonctions_totales (end)

\subsection{Extension de fonctions partielles}
\label{sub:extension_de_fonctions_partielles}

\begin{mytheo}
	Il existe une fonction partielle calculable g telle 
	qu'aucune fonction totale calculable n'est une extension de g.
\end{mytheo}

\begin{myrem}
	Ca implique que si on a une fonction partielle g, il n'est pas 
	toujours possible de créer une fonction totale f qui étend g
	tel que en dehors du domaine de g, f retourne un code d'erreur.
\end{myrem}
	
% subsection extension_de_fonctions_partielles (end)

\subsection{Théorème de Rice}
\label{sub:th_or_me_de_rice}

Soit A $\subseteq$ $\N$ \\

\begin{mytheo}
	Si A récursif et A$\neq \emptyset$ et A $\neq$ $\N$ \\
	Alors $\exists$ i $\in$ A et j $\in \N$\ A tel que $\phi _i = \phi _j$
\end{mytheo}

Par contre,

\begin{mytheo}
	Si $\forall$ i $\in$ A et $\forall$j $\in \N$\ A tel que $\phi_i \neq 
	\phi_j$ \\
	Si A non récursif et A$=\emptyset$ et A $= \N$
\end{mytheo}

\paragraph{} On est intéressé par l'analyse des propriétés d'un programme. La 
question est est-ce que ces propriétés peuvent être déterminées par un 
algorithme. On va utiliser le théorème de Rice pour caractériser les propriétés 
qu'il est possible de déterminer par un algorithme de celle pour lesquelles ce 
n'est pas possible.

\paragraph{}Pour ça, considérons A comme étant l'ensemble des programmes qui 
respecte une propriété. Par exemple $A_1$ = {i| $\phi_i$ est total} ou 
$A_2$={i|$\phi_i = f$},... (il y a plein d'exemples dans le cours).

\paragraph{Analyse} 
\begin{itemize}
	\item Si la propriété est vérifiée par certain programme, mais pas tous 
		et elle est décidable, alors il existe deux programmes calculant la 
		même fonction, mais l'un vérifie la propriété, mais pas l'autre.

	\item Si la propriété est vérifiée par un programme, mais pas tous 
		alors cette propriété ne peut-être décidée pas un algorithme.

	\item S'il existe un algorithme permettant de déterminer si un 
		programme quelconque calcule une fonction ayant cette propriété 
		alors toutes les fonctions calculables ont cette propriété ou 
		aucune fonction calculable n'a cette propriété.
	\item Aucune question relative au programme, vu sous l'angle de la 
		fonction qu'ils calculent, ne peut être décidée par 
		l'application d'un algorithme.
	\item Les propriétés intéressantes d'un programme concernant la 
		fonction qu'il calcule, non pas la forme d'un programme.
\end{itemize}

TODO preuve du théorème de RICE.


% subsection th_or_me_de_rice (end)

\subsection{Théorème de la paramétrisation}
\label{sub:th_or_me_de_la_param_trisation}

\subsubsection{Transformation de programmes}
\label{ssub:transformation_de_programmes}
On peut voir une fonction f: $\N \rightarrow \N$ comme une fonction qui prend 
le numéro d'un programme et que retourne le numéro d'un autre programme f: $P 
\rightarrow P$. Donc on peut voir $P_k$, le programme qui calcule f comme un 
transformateur de programme. En effet, $P_k$ prend un programme en entrée et 
retourne un programme qui peut être différent.

\begin{mytheo}
	\label{S-m-n}
	\textbf{S-m-n :} Pour tout $m,n \leq 0$, \\
	il existe une fonction totale calculable $S^m_n : \N^{m+1} \rightarrow 
	\N$ \\
	telle que pour tout k,
	$$ \phi^{(n+m)}_k(x_A,...,x_n,x_{n+1},...,x_{n+m}) = 
	\phi^{(n)}_{S^n(k,x_{n+1}, ...,x_{n+m})} (x_1,...,x_n)$$
\end{mytheo}

\begin{myrem}
	On peut voir le théorème \ref{S-m-n} comme : \\
	Étant donné $m,n \leq 0$\\
	il existe un transformateur de programme, $S^m_n$, qui recevant comme 
	données : 
	\begin{itemize}
		\item un programme $P_k$ à n+m arguments
		\item m valeurs $v_1,...,v_m$
	\end{itemize}
	fournit comme résultat: un programme P à n arguments tel que 
	$P(x_1,...,x_n)$ calcule la même fonction que 
	$P_k(x_1,...,x_n,,v_1,...,v_m)$
\end{myrem}

\begin{myrem}
	on peut donc voir le transformation de programmes $S^m_n$ comme un 
	programme qui particularise un autre programme à m+n argument en rendant 
	constant les m derniers paramètres.
\end{myrem}
TODO Preuve.

\begin{mytheo}
	\label{point-fixe}
	\textbf{Point fixe :} Soient $n \geq 0$ et f : fonction totale 
	calculable, il existe k tel que $\phi^{(n}_k = phi^{(n}_{f(k)}$  
\end{mytheo}

TODO Démonstration avec les lapins (les 3 lapins qui permettent
de commencer la démonstration ne sont pas super intuitif)
\begin{myrem}
	Le théorème \ref{point-fixe} n'est pas très intuitif. Mais on peut le 
	voir comme quelque soit un transformateur programme T qui calcule f 
	(n'importe quelle fonction totale calculable peut être vu comme un transformateur 
	de programme), \\
	il existe deux programmes $P_k$ et $P_j$ tels que 
	\begin{itemize}
		\item $P_j$ est la tranformation de $P_k$ via T ($k=f(j)$)
		\item $P_k$ et $P_j$ calcule la \textbf{même} fonction
	\end{itemize}
\end{myrem}

TODO demo de Rice à partir du point fixe

\subsection{Autres problèmes non calculables}
\label{sub:autres_probl_mes_non_calculable}

\begin{mydef}
	\textbf{Problème de correspondance de Post :} Soient deux listes U et V 
	de mots non vides sur un alphabet $\sum$ : 
	\begin{itemize}
		\item U = ${u_1,u_2,...,u_k}$
		\item V = ${v_1,v_2,...,v_k}$
	\end{itemize}
	Le problème consiste à décider s’ il existe une suite d'entiers 
	$i_1,i_2,..,i_n$ telle que les mots $u_{i1},u_{i_2},...,u_{in}$ et 
	$v_{i1},v_{i_2},...,v_{in}$ soient \textbf{identiquese}
\end{mydef}

\begin{mydef}
	\textbf{Problème des équations diophantines:} Décider si une équation 
	polynomiale de degré supérieur ou égal à 4 possède une solution entière.
\end{mydef}

Il n'existe pas d'algorithme résolvant ces problèmes. Il en existe bien d'autres 
dont notamment des exemples sur les grammaires dans le cours.
% subsection autres_probl_mes_non_calculable (end)

\subsection{Nombres calculables}
\label{sub:nombres_calculables}

\begin{mydef}
	Un nombre réel est défini comme la limite d'une suite (convergente) de 
	nombres rationnels. $\lim_{n \rightarrow \inf} |x-s(n)| = 0 $ ou s est 
	une fonction totale
\end{mydef}

\begin{mydef}
	Un nombre réel x est calculable s’ il existe une fonction totale 
	calculable s tel que $\lim_{n \rightarrow \inf} |x-s(n)| =\leq 2^{-n}$
\end{mydef}

\begin{myrem}
	Donc un nombre est calculable s'il existe un programme qui peut 
	l'approximer aussi près que l'on veut. Par exemple $\pi$ et $e$ sont 
	calculable
\end{myrem}

\begin{myprop}
	L'ensemble des nombres réels calculable est énumérable, car on peut énumérer les 
	fonction totale calculable.	
\end{myprop}

\begin{myprop}
	Il existe des nombres réels non calculables
\end{myprop}

\begin{myprop}
	Il existe des nombres réels non calculables qui peuvent être définis de 
	manière finie.
\end{myprop}

% subsection nombres_calculables (end)

\subsection{Conclusion}
\label{sub:conclusion}
Le théorème S-m-n permet de démontrer le théorème du point fixe.
Le théorème du point fixe est un résultat central de la calculabilité. Il 
implique le théorème de rice, la non-récursivité de K et la non-calculabilité 
de la fonction halt.

% subsection conclusion (end)



% subsubsection transformation_de_programmes (end)



% subsection th_or_me_de_la_param_trisation (end)

% Conclusion Rice => point fixe =>Rice,..
% section r_sultats_fondamentaux (end)

\end{document}
