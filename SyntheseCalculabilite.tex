\input{lib.tex}
\usepackage{pdfpages}
\usepackage{palatino}
\usepackage{enumitem}

\usepackage[bottom]{footmisc}
\usepackage{desclist}
\usepackage{tocloft}
\setlength\cftparskip{4pt}

\setlist[itemize]{topsep=3pt,after=\vspace{.5\baselineskip}}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\setlength{\parskip}{2mm}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\newcommand{\stcomp}[1]{\overline{#1}} 
\newcommand{\N}{\mathbb{N}}

% Make the style indentedefinition use bold for the name of the theorem
\makeatletter
\def\th@indenteddefinition{%
  \thm@notefont{}% same as heading font
  \normalfont % body font
}
\makeatother

\lstset{language={Java}}

\def\blurb{\textsc{Université catholique de Louvain\\
  École polytechnique de Louvain}}
\def\clap#1{\hbox to 0pt{\hss #1\hss}}%
\def\ligne#1{%
  \hbox to \hsize{%
    \vbox{\centering #1}}}%
\def\haut#1#2#3{%
  \hbox to \hsize{%
    \rlap{\vtop{\raggedright #1}}%
    \hss
    \clap{\vbox{\vfill\centering #2\vfill}}%
    \hss
    \llap{\vtop{\raggedleft #3}}}}%
\begin{document}

\begin{titlepage}
\thispagestyle{empty}\vbox to 1\vsize{%
  \vss
  \vbox to 1\vsize{%
    \haut{\raisebox{-8mm}{\includegraphics[width=2cm]{logo_ucl.pdf}}}{\blurb}{\raisebox{-3mm}{\includegraphics[scale=0.35]{logo_epl.jpg}}}
    \vfill
    \ligne{\Huge \textbf{\textsc{Synthèse calculabilité}}}
    \vspace{5mm}
    \ligne{\large{-- juin 2014 --}}
    \vfill
    \vspace{5mm}
    \ligne{%
         \textsc{Hachez} Floran 
      }
    }%
  \vss
  }
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}
\label{sec:introduction}

\paragraph{}
La calculabilité c'est l'étude des limites de l'informatique. Il faut bien 
faire attention à faire la différence entre les limites théoriques et les limites
pratiques. Pour calculabilité, on s'occupe des limites théoriques.
Alors que pour la complexité on s'occupe des limites pratiques. La complexité
détermine la frontière entre faisable en pratique et infaisable en pratique.
La question principale de la calculabilité est quels sont les problèmes qui peuvent
être résolus par un programme et lesquels ne peuvent pas.

\paragraph{} Le but est donc de tracer des frontières entre les programmes calculables,
non calculables et non calculables en pratique.

\paragraph{}
Ça nous permet de savoir quand ça ne sert à rien de résoudre un problème.
De plus, on est conscient de sa complexité intrinsèque d'un
problème.
% paragraph  (end)

\subsection{Notion de problème}
\label{subsec:notion_de_probl_me}

\paragraph{}
Premièrement, on doit parler la notion de problème.
Attention, il ne faut pas confondre un problème avec un programme.
Les caractéristiques d'un problème sont:

\begin{itemize}
	\item un problème est générique : il s'applique à un ensemble de données.
	\item pour chaque donnée particulière, il existe une réponse.
\end{itemize}
On représente un problème dans le cours par une fonction. Donc dans le cours,
la description d'un problème est équivalente à la description d'une fonction.
% paragraph  (end)
% subsection notion_de_probl_me (end)

\subsection{Notion de programme}
\label{ssub:notion_de_programme}

Un programme est une "procédure effective", c'est-à-dire exécutable par une machine.
Il existe plein de formalisme permettant la description de "procédure effective".

% subsection notion_de_programme (end)

\subsection{Résultats principaux}
\label{sub:r_sultat_principaux}

\begin{itemize}
	\item Équivalence des langages de programmation (Complet).
	\item Problème non calculable : Il existe des problèmes qui ne peuvent 
		être résolus par un programme. Ex: détection de virus, équivalence
		de programme,...
	\item Problème intrinsèquement complexe. (Voir complexité) Les problèmes
		qui ont une complexité supérieure ou égale à l'exponentielle. Dans
		ce cas même l'amélioration des ordinateurs n'influence presque pas
		la taille de l'entrée possible.
\end{itemize}

% subsection r_sultat_principaux (end)

\subsection{Détection de Virus}
\label{sub:d_tection_de_virus}
On veut déterminer si un programme P avec une entrée D est nuisible.

Spécification du programme detecteur(P,D):\\
\textbf{Préconditions :} un programme P et une donnée D\\
\textbf{Postconditions :} "Mauvais" si P(D) est nuisible,
		"Bon" sinon

\paragraph{}On va créer un programme drole(P) et essayer de détecter s’ il est nuisible.

\begin{lstlisting}
drole(P) \\
if detecteur(P,P) = "Mauvais" 
	then stop
else infecter un autre programme en y inserant P
\end{lstlisting}

Testons drole(drole).
\begin{lstlisting}
drole(drole)
if detecteur(drole, drole) = "Mauvais" 
	then stop
else infecter un autre programme en y inserant drole

\end{lstlisting}

\begin{itemize}
	\item Si drole(drole) est nuisible alors le programme s'arrête or il
	       	n'est pas nuisible puisqu'il n'a infecté aucun programme.
	\item Si par contre il n'est pas nuisible alors il va un infecter un 
		autre programme.
\end{itemize}
On a donc une contradiction ce qui implique que le programme drole ne peut 
exister, ce qui implique que  le programme détecteur non plus.
% paragraph  (end)
% subsection d_tection_de_virus (end)

% section introduction (end)Introduction

\section{Concepts}
\label{sec:concepts}

% Dans cette partie il y a pas moyen de synthétiser beaucoup.

\subsection{Ensembles, langages, relations et fonctions}
\label{sub:ensembles_langages_relations_et_fonctions}

\subsubsection{Ensembles}
\label{ssub:ensembles}
Un ensemble est une collection d'objets, sans répétition, appelés les éléments
de l'ensemble.\\

Notation : 
\begin{itemize}
	\item Ensemble fini : { 0, 1, 2}
	\item Ensemble infini : { 0, 1, 2, ...}
	\item Produit cartésien : A x B
	\item Complément : $\stcomp{A}$
\end{itemize}

% subsubsection ensembles (end)

\subsubsection{Langages}
\label{ssub:Langages}
Notation : 
\begin{itemize}
	\item une chaîne de caractère ou un mot : séquence FINIE de symboles. 
		abceced, 010101101
	\item chaîne de caractères vide : $\epsilon$
	\item un alphabet $\sum$ est un ensemble de symboles. $\sum = {1, 2}$
	\item un langage est un ensemble de mots constitués de symboles d'un alphabet
		donné.
	\item ensemble de tous les mots possible avec $\sum$ : $\sum ^*$
\end{itemize}

% subsubsection Langages (end)

\subsubsection{Relations}
\label{ssub:relations}
Soient A, B des ensembles.
\begin{itemize}
	\item Une relation R sur A, B est un sous-ensemble de A x B. C'est-à-dire
		un ensemble de paires <a,b> avec $a\in A$ $b\in B$.
	\item On peut définir une relation par sa table
	\item On peut écrire <a,b> $\in$ R ou aRb ou R(a,b) 
\end{itemize}

% subsubsection relations (end)

\subsubsection{Fonctions}
\label{ssub:fonctions}
Soient A, B des ensembles.
\begin{itemize}
	\item Une fonction f: A $\rightarrow$ B est une relation telle que a $\in$
	A, il existe au plus un b $\in$ B tel que <a,b> $\in$ f
	\item écrire f(a)=b est équivalent à <a,b> $\in$ f
	\item Si il n'existe pas de b $\in$ B tel que f(a)=b alors f(a) est indéfini,
		f(a) = $\perp$
\end{itemize}

Dans le cours on utilise les propriétés classiques: dom(f), image(f), fonction totale,
fonction partielle, fonction surjective, injective et injective. Celles-ci ne 
seront pas redéfinies ici.\\
On utilise aussi l'\textbf{extension} : 
f est une extension de g si $\forall x \in A$ : $g(x)\neq \perp \Rightarrow f(x) = g(x)$
Autrement dit, f a la même valeur que g partout où g est définie.

\paragraph{Définition d'une fonction}
\label{par:d_finition_d_une_fonciton}
On définit une fonction par sa table qui peut-être infinie.\\
On peut définir la table de plusieurs façons :
\begin{itemize}
	\item Par un texte fini déterminant sans contradiction ni ambigüité le contenu
		de la table.
	\item Par un algorithme ex : f(x) = $2x^3+5$
	\item Écrire toutes les paires de la relation.
\end{itemize}
Attention, il n'est pas nécessaire de décrire ou de connaître un moyen de la calculer
pour pouvoir la définir. Ex : f(x) = 1 s'il y a de la vie autre part que sur terre,
0 sinon.
% paragraph d_finition_d_une_fonction (end)
% subsubsection fonctions (end)
% subsection ensembles_langages_relations_et_fonctions (end)

\subsection{Ensemble énumérable}
\label{sub:ensemble_num_rables}

Avant de dire ce qu'est un ensemble énumérable, on doit savoir que deux ensembles
ont le même cardinal s’il existe une bijection entre eux.

\paragraph{}
Un ensemble est énumérable ou dénombrable si soit il est fini ou il a le même cardinal que $\mathbb{\N}$. \\
Quelques propriétés : 
\begin{myprop}
	Tout sous-ensemble d'un ensemble énumérable est énumérable.
\end{myprop}

\begin{myprop}
L'union et l'intersection de deux ensembles énumérables sont énumérables.
\end{myprop}

\begin{myprop}
L'union d'une infinité d'ensembles énumérables est énumérable. (Facile à
		démontrer voir TP)
\end{myprop}

Quelques ensembles non énumérables : 
\begin{myexem}
 L'ensemble $\R$
\end{myexem}

\begin{myexem}
 L'ensemble des sous-ensembles de $\N$
\end{myexem}

\begin{myexem}
 L'ensemble des chaînes infinies de caractère sur un alphabet fini
\end{myexem}

\begin{myexem}
 L'ensemble des fonctions de $\N$ dans $\N$ (Cas important)
\end{myexem}

% subsection ensemble_num_rables (end)

\subsection{Cantor}
\label{sub:cantor}
On va montrer qu'il existe des ensembles non énumérables. Ex $\R$.
L'idée de la démonstration est de :
\begin{enumerate}
	\item Supposer que l'ensemble est énumérable
 	\item Construire une table contenant une soi-disant énumération
	\item Sélectionner la diagonale et dire qu'on doit l'énumérer
	\item Modifier l'élément égal à la diagonale
	\item Montrer que l'élément n'est pas dans l'énumération => Contradiction
	\item Conclusion l'ensemble est pas énumérable
\end{enumerate}
On montre que quand on essaye d'énumérer on loupe toujours des éléments.

TO DO

% subsection cantor (end)

\subsection{Conclusion}

Les ensembles énumérables sont importants pour la suite du cours et aussi, car en 
informatique on ne considère que les ensembles énumérables.
Dans le cours, on va souvent devoir montrer qu'un ensemble est énumérable/non énumérable.
Généralement on va utiliser une des techniques suivantes: 
\begin{itemize}
	\item montrer qu'il y a une bijection avec $\N$ ou $\R$
	\item montrer que l'ensemble est fini
	\item utiliser la diagonalisation (cf. Cantor)
	\item écrire un programme qui énumère l'ensemble
\end{itemize}

% subsection conclusion (end)
% section concepts (end)

\section{Résultats fondamentaux}
\label{sec:r_sultats_fondamentaux}

\subsection{Algorithmes et effectivité}
\label{sub:algorithmes_et_effectivit_}
Qu'est-ce qu'un algorithme? C'est une procédure qui peut être appliquée à n'importe
quelles données et qui a pour effet de produire un résultat. C'est un ensemble fini
d'instructions qui peuvent être exécutées. Dans ce cours, on ne tracasse pas 
de la taille des données, des instructions ni de la mémoire disponible, mais 
les considères comme finies. 

\begin{myrem}
	Un algorithme n'est pas une fonction, mais un algorithme calcule une 
	fonction.
	De plus dans le cours on se limite aux fonctions de $\N^n$ dans $\N$. Car on peut,
	montrer que ça revient au même que de considéré de $\N^n$ dans $\N^n$ (
	$\N^n$ est énumérable et donc au plus de même cardinal que $\N$). On va aussi
	utiliser Java comme modèle étant donné que c'est plus facile et qu'on va montrer 
	que les modèles complets sont équivalents.
\end{myrem}

% subsection algorithmes_et_effectivit_ (end)

\subsection{Fonctions calculables, ensembles récursifs et récursivement énumérables}
\label{sub:fonctions_calculables_ensembles_r_crusids_et_r_cursivement_num_rables}

\subsubsection{Fonction calculable}
\label{ssub:fonction_calculable}
Une fonction est calculable s’ il existe un algorithme qui, recevant comme donnée
n'importe quels nombres naturels $X_1$,...$X_n$ fourni \textbf{tôt ou tard} comme 
résultat f(x) s’il existe.
\paragraph{} S’il ne se termine pas c'est que $f(x)=\perp$. \\

\begin{myrem}
	De plus, il faut faire attention entre ne pas être capable d'écrire un algorithme
	et ne pas savoir l'écrire. (Voir exemple TP et cours : rose vert sur Mars ou encore
	x occurrences de 5 dans $\pi$.
\end{myrem}

\begin{myrem}
	Une fonction peut-être totale calculable ou partielle calculable.
\end{myrem}

% subsubsection fonction_calculable (end)

\subsubsection{Ensemble récursif et récursivement énumérable}
\label{ssub:ensemble_r_cursif_et_r_cursivement_num_rable}
Soit $A\subseteq \N$

\begin{mydef}
	A est récursif s’ il existe un algorithme qui recevant un $X\in \N$
	, fourni \textbf{tôt ou tard} comme résultat 
	\begin{tabular}{l}
		1 si $x\in A$\\
		0 si $x\notin A$\\
	\end{tabular}
	. L'algorithme décide si x est dans A ou non.
\end{mydef}

\begin{mydef}
	A est récursivement énumérable s’ il existe un algorithme qui recevant
	un $X\in \N$, fourni \textbf{tôt ou tard} comme résultat
	\begin{tabular}{l}
		1 si $x\in A$\\
		 ne se termine pas ou retourne un résultat $\neq1$ si
		 $x\notin A$\\
	\end{tabular}
\end{mydef}

\begin{myrem}
		Le souci c'est que même si l'algorithme permet de dire si x est dans A, si x
		n'est pas dans A on ne sait rien dire, car on ne peut pas dire à un moment qu'on
		arrête l'algorithme. Car c'est possible que x soit dans A et que l'algorithme ne
		l'a pas encore déterminé (retourne tôt ou tard !).
\end{myrem}

\paragraph{Définition importante :}
\label{par:d_finition_importante}

\begin{mydef}
	Fonction caractéristique de A:
	$X_A$ : $\N$ $\rightarrow$ $\N$ tel que $X_A(x)$ =
\begin{tabular}{l}
	1 si x $\in$ A \\	
	0 si x $\notin$ A 
\end{tabular}
\end{mydef}

\begin{mydef}
	A est un ensemble récursif ssi $X_A$ est une fonction totale calculable. Ce qui
	est évident, ça veut dire qu'il existe une fonction $X_A$ qui décide si n'importe
	qu'elle x appartient ou non à A.\\
\end{mydef}

\begin{mydef}
	A est un ensemble récursivement énumérable ssi A = dom(f) et $X_A$ est une 
	fonction (totale ou partielle) calculable. En effet, si f(x) est défini alors
	x appartient à A.\\
\end{mydef}

\begin{mydef}
	A est un ensemble récursivement énumérable ssi A est vide ou A = image(f) et f
	est une fonction totale calculable. Car f est une fonction d'énumération (elle
	peut répéter plusieurs fois un élément, mais ce n'est pas gênant).\\
\end{mydef}

% paragraph d_finition_importante (end)

\paragraph{Propriétés importantes}
\label{par:propri_t_s_importantes}
\begin{myprop}
	A récursif $\Rightarrow$ A récursivement énumérable. (Propriété plus
		faible)
\end{myprop}

\begin{myprop}
	A récursif $\Rightarrow$ ($\N$ \ A) énumérable.\\ On peut facilement créer
		un programme qui retourne 1 - le programme qui décide A.
\end{myprop}

\begin{myprop}
	A récursivement énumérable et ($\N$ \ A) récursivement énumérable 
		$\Rightarrow$ A récursivement énumérable.\\ Il suffit de créer un programme
		qui exécuté un peu du programme qui décide A puis un peu de celui qui
		décide ($\N$ \ A). \\Jusqu'au moment ou l'un des programmes retourne une
		réponse.
\end{myprop}

\begin{myprop}
	A fini $\Rightarrow$ A récursif. (Trivial)
\end{myprop}

\begin{myprop}
	($\N$ \ A) fini $\Rightarrow$ A récursif. (Trivial)
\end{myprop}


% paragraph propri_t_s_importantes (end)
% subsubsection ensemble_r_cursif_et_r_cursivement_num_rable (end)
% subsection fonctions_calculables_ensembles_r_crusids_et_r_cursivement_num_rables (end)

\subsection{Thèse de Church-Turing}
\label{sub:th_se_de_church_turing}
Grâce à la définition, on sait montrer qu'une fonction est calculable. Mais comment
montrer qu'une fonction n'est pas calculable? Pour ça on a besoin d'une définition
couvrant la totalité des fonctions calculables. \\
Une autre question est est-ce que prendre un modèle particulier est restrictif?\\
La thèse de Turing répond à ces questions.
\begin{enumerate}
	\item Aucun modèle de la notion de fonction calculable n'est plus puissant
		que les Machines de Turing \\
		Version moderne : Une fonction est calculable s'il existe un 
		programme d'ordinateur qui calcul cette fonction
	\item Toute fonction calculable est calculable par une machine de Turin.
	\item Toutes les définitions formelles de la calculabilité connues à ce 
		jour sont équivalentes (Théorème, ça a été démontré) (justifie 
		l'utilisation de Java comme modèle)
	\item Toutes les formalisations de la calculabilité établies par la 
		suite seront équivalentes aux définitions connues
\end{enumerate}
1, 2 et 4 sont des thèses universellement reconnues comme vraies.

% subsection th_se_de_church_turing (end)

\subsection{Programmes et fonctions}
\label{sub:programmes_et_fonctions}
Dans le cours on utilise un langage de programmation, Java, comme modèle.

\begin{mydef}
	Soit P l'ensemble des programmes Java qui reçoit un ou plusieurs entiers comme 
	donnée et qui imprime/retourne un résultat.
\end{mydef}

\begin{myprop}
	P est un ensemble infini dénombrable (chaîne de caractère d'un 
	alphabet fini) récursif (il existe un programme, le compilateur, qui détermine 
	si un programme est un programme Java ou non).
\end{myprop}

\begin{mydef}
	P = $P_0$, $P_1$,... ,$P_k$,... (énumération des programmes Java 
	sans répétition). Ce qui implique qu'on peut numéroter les programmes Java.\\
\end{mydef}

\begin{mydef}
	$P_k$ est le programme k dans P et $\phi^{(n)}_k$ : $\N^n 
	\rightarrow \N$ comme étant la fonction calculée pas $P_k$
\end{mydef}


\begin{myprop}
	Il existe donc une fonction f : $\N\rightarrow P$ telle que :
	\begin{itemize}
		\item f(k) = $P_k$
		\item f calculable
		\item k (numéro d'un programme) et $P_k$ sont deux représentations 
			distinctes d'un même objet.
	\end{itemize}
\end{myprop}

% subsection programmes_et_fonctions (end)

\subsection{Existence de fonctions non calculable}
\label{sub:existence_de_fonction_non_calculables}
Il existe beaucoup de fonctions non calculables, car le nombre de fonctions de $\N$ 
dans $\N$ est non dénombrable (Démo par Cantor lors d'un TP). Or le nombre de 
programmes Java est dénombrable. Donc il y a beaucoup de fonctions qui ne sont 
pas calculables.

\paragraph{} On va s'intéresser qu'aux fonctions qui sont définies par une table 
finie (on ne sait pas définir les tables infinies). Il en existe une infinité 
dénombrable.

\paragraph{} On va maintenant montrer que ce n'est pas parce qu’une fonction 
est définie par une table finie qu'elle est nécessairement calculable (avec la 
fonction halt qui détermine si un programme se termine ou non).

% subsection existence_de_fonction_non_calculables (end)

\subsection{Problème de l'arrêt}
\label{sub:probl_me_de_l_arr_t}

Soit la fonction halt: P x $\N$ $\rightarrow$ $\N$ telle que \\
\begin{tabular}{rl}
  halt(n, x) = 1 & si $P_n(x)$ se termine \\
  halt(n, x) = 0 & sinon \\
  ou &\\
  halt(n, x) = 1 & si $\phi_n(x)\neq \perp$ \\
  halt(n, x) = 0 & sinon \\
\end{tabular}

\begin{myprop}
	halt est une fonction bien définie, totale et sa table est infinie, mais décrite 
	de manière finie. Or on va montrer que halt n'est pas calculable par 
	diagonalisation (comme pour la démonstration de Cantor).\\
\end{myprop}

TODO \\

\paragraph{Conclusion} Il n'existe pas d'algorithme qui détermine si n'importe 
quel programme $P_n$ se termine ou non. Mais dans certains formalismes qui ne 
sont pas des modèles complets. Par exemple un langage qui ne permet de calculer 
que des fonctions totale (exemple java sans aucune boucle)
, halt est calculable (halt retourne toujours 1). \\

De plus, il faut faire attention, car ce n'est pas parce que halt n'est pas 
calculable que pour un programme donné k, $halt(k,x)$ est non calculable. Par 
exemple $halt(32,123)$ est une fonction constant donc calculable (ce n'est pas 
pour autant qu'on est capable d'écrire l'algorithme), $halt(32,x)$ peut-être 
calculable, mais ça dépend du 
programme 32, par exemple si celui-ci est constant.

\begin{myrem}
	Cette partie du cours est très importante, car on a trouvé un 
	"trou dans le mur des fonctions calculables" et on va étendre le trou (métaphore
	de Mr Deville). C'est-à-dire que maintenant on va utiliser halt pour montrer 
	que d'autres fonctions sont calculables/non calculable. Par exemple 
	par réduction, en effet, si on peut calculer halt grâce à une fonction 
	alors celle-ci n'est pas calculable.
\end{myrem}

Il existe donc au moins un ensemble non récursif (dans notre 
modèle?)\\
K = 
\begin{tabular}{l}
	\{n|(n,n)$\in$ HALT\}\\
	\{n| halt(n,n)=1\}\\
	\{n| $P_n(b)$ se termine\} \\
\end{tabular}

Où HALT est l'ensemble des programmes k qui se termine pour l'entrée x, 
HALT = {(n,x)|$P_n(x)$ se termine}). Et K est l'ensemble des programmes n qui
se termine pour l'entrée n.

\begin{myprop}
	K et HALT ne sont pas récursifs
\end{myprop}
	
\begin{myprop}
	K et HALT sont récursivement énumérables (car il suffit de lancer le 
	programme et s’il retourne quelque chose il se termine sinon on ne sait 
	pas)
\end{myprop}
	
\begin{myprop}
	$\stcomp{HALT}$ n'est pas récursivement énumérable sinon HALT 
		serait récursif.
\end{myprop}
	
\begin{myprop}
	$\stcomp{K}$ n'est pas récursivement énumérable
\end{myprop}
	

TODO insérer le schéma sur les fonctions et les ensembles

\begin{mydef}[Un ensemble co-récursivement énumérable] est un ensemble dont le 
	complément est récursivement énumérable. Par exemple $\stcomp{HALT}$. On peut 
	en déduire que si un ensemble est récursivement énumérable et co-récursivement 
	énumérable alors il est récursif.
\end{mydef}

% subsection probl_me_de_l_arr_t (end)

\subsection{Insuffisance des fonctions totales}
\label{sub:insuffisance_des_fonctions_totales}
Comme on a vu qu'il était possible de calculer halt dans un modèle qui
permet de calculer que des fonctions totales, on se pose la question de 
pourquoi on n'utilise pas un tel modèle. De plus les fonctions "pratiques" sont 
des fonctions totales. Mais on va montrer qu'un tel modèle nous restreint 
beaucoup sur ce qu'on peut calculer.

\begin{myexem}
	Un tel modèle est par exemple Java, mais sans boucle 
	donc par intuition on se doute qu'il y a beaucoup de choses qu'on ne peut pas 
	calculer.
\end{myexem}

\begin{mydef}
	Posons Q un langage dont tous les programmes se terminent et pour 
	lequel il existe un interpréteur calculable, interpret(n,x)=$\phi'_n$. Où
	$\phi'_k$ est la fonction calculée par le programme $Q_k$. L'interpréteur est une 
	fonction totale.
\end{mydef}

\begin{mytheo}[Hoare-Allison]
	\label{Hoare_Allison}
	interpret(n,x) n'est pas calculable dans Q.\\
	TODO démonstration par diagonalisation
\end{mytheo}



\subsubsection{Implication du théorème \ref{Hoare_Allison} }

\begin{myprop}
	Si un langage ne permet que le calcul de fonction total alors :
	\begin{itemize}
		\item l'interpréteur de ce langage n'est pas calculable dans ce langage
		\item il existe des fonctions totales non programmables dans ce langage
		\item ce langage est \bf{restrictif}
	\end{itemize}
\end{myprop}
	
\begin{myprop}
	Si un langage permet de programmer son propre interpréteur alors il ne permet 
	pas de programmer la fonction halt de ce langage.
\end{myprop}

\begin{myprop}
	Dans un langage de programmation, il est donc impossible que 
	l'interpréteur et la fonction halt (de ce langage) puissent être programmés dans ce langage.
\end{myprop}

\begin{myprop}
	Si on veut pouvoir programmer toutes les fonctions 
	totales dans un langage, le langage doit permettre la programmation de 
	fonctions non totales.
\end{myprop}

\begin{myprop}
	L'ensemble {n| $\phi_n$ est totale} n'est pas récursif. (sinon on 
	saurait créer un langage qui ne calcule que des fonctions totales??)
\end{myprop}

TODO insérer la fonction universelle ???

% subsection insuffisance_des_fonctions_totales (end)

\subsection{Extension de fonctions partielles}
\label{sub:extension_de_fonctions_partielles}

\begin{mytheo}
	Il existe une fonction partielle calculable g telle 
	qu'aucune fonction totale calculable n'est une extension de g.
\end{mytheo}

\begin{myrem}
	Ca implique que si on a une fonction partielle g, il n'est pas 
	toujours possible de créer une fonction totale f qui étend g
	tel que en dehors du domaine de g, f retourne un code d'erreur.
\end{myrem}
	
% subsection extension_de_fonctions_partielles (end)

\subsection{Théorème de Rice}
\label{sub:th_or_me_de_rice}

Soit A $\subseteq$ $\N$ \\

\begin{mytheo}
	Si A récursif et A$\neq \emptyset$ et A $\neq$ $\N$ \\
	Alors $\exists$ i $\in$ A et j $\in \N$\ A tel que $\phi _i = \phi _j$
\end{mytheo}

Par contre,

\begin{mytheo}
	Si $\forall$ i $\in$ A et $\forall$j $\in \N$\ A tel que $\phi_i \neq 
	\phi_j$ \\
	Si A non récursif et A$=\emptyset$ et A $= \N$
\end{mytheo}

\paragraph{} On est intéressé par l'analyse des propriétés d'un programme. La 
question est est-ce que ces propriétés peuvent être déterminées par un 
algorithme. On va utiliser le théorème de Rice pour caractériser les propriétés 
qu'il est possible de déterminer par un algorithme de celle pour lesquelles ce 
n'est pas possible.

\paragraph{}Pour ça, considérons A comme étant l'ensemble des programmes qui 
respecte une propriété. Par exemple $A_1$ = {i| $\phi_i$ est total} ou 
$A_2$={i|$\phi_i = f$},... (il y a plein d'exemples dans le cours).

\paragraph{Analyse} 
\begin{itemize}
	\item Si la propriété est vérifiée par certain programme, mais pas tous 
		et elle est décidable, alors il existe deux programmes calculant la 
		même fonction, mais l'un vérifie la propriété, mais pas l'autre.

	\item Si la propriété est vérifiée par un programme, mais pas tous 
		alors cette propriété ne peut-être décidée pas un algorithme.

	\item S'il existe un algorithme permettant de déterminer si un 
		programme quelconque calcule une fonction ayant cette propriété 
		alors toutes les fonctions calculables ont cette propriété ou 
		aucune fonction calculable n'a cette propriété.
	\item Aucune question relative au programme, vu sous l'angle de la 
		fonction qu'ils calculent, ne peut être décidée par 
		l'application d'un algorithme.
	\item Les propriétés intéressantes d'un programme concernant la 
		fonction qu'il calcule, non pas la forme d'un programme.
\end{itemize}

TODO preuve du théorème de RICE.


% subsection th_or_me_de_rice (end)

\subsection{Théorème de la paramétrisation}
\label{sub:th_or_me_de_la_param_trisation}

\subsubsection{Transformation de programmes}
\label{ssub:transformation_de_programmes}
On peut voir une fonction f: $\N \rightarrow \N$ comme une fonction qui prend 
le numéro d'un programme et que retourne le numéro d'un autre programme f: $P 
\rightarrow P$. Donc on peut voir $P_k$, le programme qui calcule f comme un 
transformateur de programme. En effet, $P_k$ prend un programme en entrée et 
retourne un programme qui peut être différent.

\begin{mytheo}[S-m-n] 
	\label{S-m-n}Pour tout $m,n \leq 0$, \\
	il existe une fonction totale calculable $S^m_n : \N^{m+1} \rightarrow 
	\N$ \\
	telle que pour tout k,
	$$ \phi^{(n+m)}_k(x_A,...,x_n,x_{n+1},...,x_{n+m}) = 
	\phi^{(n)}_{S^n(k,x_{n+1}, ...,x_{n+m})} (x_1,...,x_n)$$
\end{mytheo}

\begin{myrem}
	On peut voir le théorème \ref{S-m-n} comme : \\
	Étant donné $m,n \leq 0$\\
	il existe un transformateur de programme, $S^m_n$, qui recevant comme 
	données : 
	\begin{itemize}
		\item un programme $P_k$ à n+m arguments
		\item m valeurs $v_1,...,v_m$
	\end{itemize}
	fournit comme résultat: un programme P à n arguments tel que 
	$P(x_1,...,x_n)$ calcule la même fonction que 
	$P_k(x_1,...,x_n,,v_1,...,v_m)$
\end{myrem}

\begin{myrem}
	On peut donc voir la transformation de programmes $S^m_n$ comme un 
	programme qui particularise un autre programme à m+n argument en rendant 
	constant les m derniers paramètres.
\end{myrem}
TODO Preuve.

\begin{mytheo}[Point fixe] 
	\label{point-fixe}Soient $n \geq 0$ et f : fonction totale 
	calculable, il existe k tel que $\phi^{(n}_k = phi^{(n}_{f(k)}$  
\end{mytheo}

TODO Démonstration avec les lapins (les 3 lapins qui permettent
de commencer la démonstration ne sont pas super intuitifs)
\begin{myrem}
	Le théorème \ref{point-fixe} n'est pas très intuitif. Mais on peut le 
	voir comme quelque soit un transformateur programme T qui calcule f 
	(n'importe quelle fonction totale calculable peut être vu comme un transformateur 
	de programme), \\
	il existe deux programmes $P_k$ et $P_j$ tels que 
	\begin{itemize}
		\item $P_j$ est la transformation de $P_k$ via T ($k=f(j)$)
		\item $P_k$ et $P_j$ calcule la \textbf{même} fonction
	\end{itemize}
\end{myrem}

TODO demo de Rice à partir du point fixe

\subsection{Autres problèmes non calculables}
\label{sub:autres_probl_mes_non_calculable}

\begin{mydef}[Problème de correspondance de Post] Soient deux listes U et V 
	de mots non vides sur un alphabet $\sum$ : 
	\begin{itemize}
		\item U = ${u_1,u_2,...,u_k}$
		\item V = ${v_1,v_2,...,v_k}$
	\end{itemize}
	Le problème consiste à décider s’ il existe une suite d'entiers 
	$i_1,i_2,..,i_n$ telle que les mots $u_{i1},u_{i_2},...,u_{in}$ et 
	$v_{i1},v_{i_2},...,v_{in}$ soient \textbf{identique} \\
	Pour démontrer l'indécidabilité de ce problème, Post à introduit un 
	nouveau modèle, la machine de Post qui ressemble à une machine de Turing.
\end{mydef}

\begin{mydef}[Problème des équations diophantines:] Décider si une équation 
	polynomiale de degré supérieur ou égal à 4 possède une solution entière.
\end{mydef}

Il n'existe pas d'algorithme résolvant ces problèmes. Il en existe bien d'autres 
dont notamment des exemples sur les grammaires dans le cours.
% subsection autres_probl_mes_non_calculable (end)

\subsection{Nombres calculables}
\label{sub:nombres_calculables}

\begin{mydef}
	Un nombre réel est défini comme la limite d'une suite (convergente) de 
	nombres rationnels. $\lim_{n \rightarrow \inf} |x-s(n)| = 0 $ ou s est 
	une fonction totale
\end{mydef}

\begin{mydef}
	Un nombre réel x est calculable s’ il existe une fonction totale 
	calculable s tel que $\lim_{n \rightarrow \inf} |x-s(n)| =\leq 2^{-n}$
\end{mydef}

\begin{myrem}
	Donc un nombre est calculable s'il existe un programme qui peut 
	l'approximer aussi près que l'on veut. Par exemple $\pi$ et $e$ sont 
	calculable
\end{myrem}

\begin{myprop}
	L'ensemble des nombres réels calculable est énumérable, car on peut énumérer les 
	fonction totale calculable.	
\end{myprop}

\begin{myprop}
	Il existe des nombres réels non calculables
\end{myprop}

\begin{myprop}
	Il existe des nombres réels non calculables qui peuvent être définis de 
	manière finie.
\end{myprop}

% subsection nombres_calculables (end)

\subsection{Conclusion}

Le théorème S-m-n permet de démontrer le théorème du point fixe.
Le théorème du point fixe est un résultat central de la calculabilité. Il 
implique le théorème de rice, la non-récursivité de K et la non-calculabilité 
de la fonction halt.

% subsection conclusion (end)
% section r_sultats_fondamentaux (end)

\section{Modèle de la calculabilité}
\label{sec:mod_le_de_la_calculabilit_}

\subsection{Familles de modèles}
\label{sub:fammilles_de_mod_les}

Il y a deux grandes familles de modèles :
\begin{itemize}
	\item Modèle de calcul
	\item Modèle de langages
\end{itemize}

\subsubsection{Modèle de calcul}
\label{ssub:mod_le_de_calcul}
L'objectif est de modéliser le concept de fonctions calculables, processus de 
calcul, algorithme effectif.

\paragraph{} on peut encore classer les modèles de calcul en 2 catégories, les 
modèles déterministes et les modèles non déterministes.

\begin{mydef}[Modèles déterministes] une seule exécution possible
\end{mydef}

\begin{mydef}[Modèles non déterministes] il existe plusieurs exécutions 
	possibles
\end{mydef}

On va voir les modèles de calcul suivant : 
\begin{itemize}
	\item Automate fini
	\item Automate à pile
	\item Machine de Turing
	\item Langages de programmation
	\item Lambda calcul
	\item Fonction récursive
\end{itemize}

Mais, il en existe beaucoup d'autres.
% subsubsection mod_le_de_calcul (end)

\subsubsection{Modèle de langage}
\label{ssub:mod_le_de_langage}
Un langage est défini pas une grammaire formelle. L'objectif est de modéliser 
une classe de langage. Le langage est alors soit un ensemble récursif ou un 
ensemble récursivement énumérable.

% subsubsection mod_le_de_langage (end)
% subsection fammilles_de_mod_les (end)

\subsection{Langages de programmation}
\label{sub:langages_de_programmation}
C'est un modèle possible de la calculabilité. Pour définir un langage de 
programmation comme modèle de la calculabilité, il faut définir : 
\begin{itemize}
	\item Syntaxe du langage
	\item Sémantique du langage
	\item Convention de représentation d'une fonction par un programme
\end{itemize}

On se pose de la question est-ce qu'il y a des langages plus puissants que 
d'autre. On va montrer que tous les langages complets sont équivalents. (Et la 
plus par des langages sont complet).

\paragraph{} Mais, il existe aussi des langages qui ne sont pas complets comme le 
langage BLOOP (bounded loop).

\begin{mydef}
	BLOOP : Sous ensemble de Java qui ne calcule que des fonctions totales. 
	(pas de boucle while, boucle for mais sans modification du compteur 
	dans le for, pas de goto, pas de fonctions récursives)
\end{mydef}

BLOOP a donc toutes les propriétés qui découlent du chapitre précédent.

% subsection langages_de_programmation (end)

\subsubsection{Langage de programmation non déterministe}
\label{ssub:langague_de_programmation_non_d_terministe}

\begin{myrem}
	Il est difficile d'avoir de l'intuition sur cette partie. Mais on peut 
	voir un programme ND comme un programme qui produit des résultats 
	différents d'une exécution à l'autre, mais concernant la complexité on 
	considère qu'il trouve directement la solution. C'est pourquoi on ne 
	considère que la profondeur de l'arbre pour la complexité.
\end{myrem}

On va un introduire un nouveau langage ND-Pascal qui est le langage java 
auquel on ajoute le non-déterminisme. C'est à dire on ajout la fonction 
prédéfinie $choose(n)$. Celle-ci retourne un entier compris entre 0 et n et elle 
est non déterministe.

\paragraph{} On peut voir un programme ND de 2 manières différentes :

\begin{enumerate}
	\item Il calcule une relation plutôt qu'une fonction
	\item Le voir comme un moyen de décider si un élément appartient à un 
		ensemble
\end{enumerate}

On considère l'approche 2 en calculabilité.

\begin{mydef}
	Un ensemble $A \subseteq \N$ est \textbf{ND-récursif} s’il existe un 
	ND-programme tel que lorsqu'il reçoit comme donnée n'importe quel nombre 
	naturel x \\
	\begin{tabular}{c}
	si $x \in A$ alors il existe une exécution fournissant tôt ou tard 
	comme résultat 1 \\
	si $x \notin A$ alors toutes les exécutions fournissent tôt ou tard 
	comme résultat 0 \\
	\end{tabular}
\end{mydef}

\begin{mydef}
	Un ensemble $A \subseteq \N$ est \textbf{ND-récursivement énumérable} s’il existe un 
	ND-programme tel que lorsqu'il reçoit comme donnée n'importe quel nombre 
	naturel x
	\begin{tabular}{c}
	si $x \in A$ alors il existe une exécution fournissant tôt ou tard 
	comme résultat 1 \\
	si $x \notin A$ alors les exécutions possibles ne se terminent pas ou 
	retournent un résultat $\neq 1$ \\
	\end{tabular}
\end{mydef}

\begin{myprop}
	On peut simuler les exécutions d'un ND-programme à l'aide d'un programme 
	déterministe. (BFS dans l'arbre d'exécution)
\end{myprop}

\begin{mytheo}
	Un ensemble est ND-récursif ssi il est récursif
\end{mytheo}

\begin{mytheo}
	Un ensemble est ND-récursivement énumérable ssi il est récursivement 
	énumérable
\end{mytheo}

\subsection{Automates finis FA}
\label{sub:automates_finis}

\paragraph{Objectif :} Décider si un mot donné appartient ou non à un langage.

\paragraph{Utilisation :} Utiliser dans les interfaces avec les humains par 
exemple les distributeurs.

\subsubsection{Modèles des automates finis}
\label{ssub:mod_les_des_automates_finis}
Un automate fini est composé de :

\begin{itemize}
	\item $\sum$ : ensemble fini de symboles
	\item $S$ : ensemble fini d'états
	\item $s_0 \in S$ : état initial
	\item $A \subseteq S$ : ensemble des états acceptant
	\item $\delta$: $S$x$\sum \rightarrow S$ : fonction de transition
\end{itemize}

\begin{myrem}
	On peut aussi représenter un automate fini à l'aide d'un diagramme 
	d'état.
\end{myrem}

\paragraph{Fonctionnement}
\begin{itemize}
	\item départ avec un état initial
	\item parcours des symboles du mot d'entrée, un à un
	\item à chaque symbole lu, l'état change (fonction de transition 
		$\delta$) en fonction de l'état courant et du symbole lu
	\item état final est l'état après avoir parcouru tous les symboles en 
		entrée
	\item l'état final peut-être acceptant ou non
\end{itemize}

\begin{myrem}
	Il n'y a donc pas de mémoire. De plus, un automate peut-être simulé 
	par un programme Java.
\end{myrem}

\begin{myprop}
	Un automate fini défini un ensemble récursif de mots $=\{m|m$ est 
		accepté par FA$\}$
\end{myprop}

\begin{myprop}
	Certains ensembles récursifs ne peuvent pas être reconnus par un 
	automate fini. Par exemple $L = { a^n b^n | n\geq 0}$ (il me semble que 
	c'est par ce que ça nécessiterait un nombre infini d'états)
\end{myprop}

\begin{myprop}
	L'interpréteur des automates finis est calculable, mais ne peut pas être 
	représenté par un automate fini, car ce n'est pas un \textbf{modèle 
	complet} de la calculabilité (Hoare Allison)
\end{myprop}

\begin{mydef}[Langage régulier] est un langage défini par une expression 
	régulière.
\end{mydef}

\begin{mydef}
	Expression régulière :  dans le cours on prend comme syntaxe, "+" pour 
	signifié ou, "." pour signifier la concaténation, "*" pour la 
	fermeture (???) et "()" pour la répétition.
\end{mydef}
% subsubsection mod_les_des_automates_finis (end)

\subsubsection{Automate fini ND}
\label{ssub:automate_fini_nd}
On étend le modèle en permettant d'avoir plusieurs transitions possibles pour 
une paire <état,symbole>. Ce qui implique que plusieurs exécutions sont 
possibles.

\paragraph{} De même que pour un ND programme, un mot est accepté par un NDFA 
s’il existe au moins une exécution ou l'état final est acceptant. Dans l'autre 
sens, un 
mot n'est pas accepté si toute exécution ne se termine pas avec l'état final 
acceptant.

\begin{myprop}
	Si un ensemble récursif est défini par un NDFA, alors cet ensemble est 
	défini par un FA.
\end{myprop}

\begin{myprop}
	Un NDFA définit un ensemble récursif de mots
\end{myprop}

\paragraph{Ajout de transitions vides $\epsilon$} on peut encore étendre le modèle NDFA en 
rajoutant une possibilité de transition sans lire de symbole (transition 
spontanée). Ça a la même puissance et les mêmes propriétés qu'un NDFA.

% subsubsection automate_fini_nd (end)

\subsection{Automate à pile PDA}
\label{sub:automate_pile}
C'est une extension du modèle des automates finis. On ajoute une mémoire avec 
la pile de symboles.
Les différences principales sont :
\begin{itemize}
	\item la transition entre états dépend du symbole lu et du symbole au 
		sommet de la pile
	\item	chaque transition peut enlever le sommet de la pile et empiler 
		de nouveaux éléments ou ne pas changer la pile.
\end{itemize}

\paragraph{Objectif :} Décider si le mot donné appartient ou non à un langage.

\paragraph{Utilisation :} Utiliser dans les compilateurs

\paragraph{Composition :}
On rajoute $\Gamma$ et on change la fonction de transition en une nouvelle 
relation de transition.
\begin{itemize}
	\item $\sum$ : ensemble fini de symboles d'entrée
	\item $\Gamma$ : ensemble fini de symboles de pile
	\item $S$ : ensemble fini d'états
	\item $s_0 \in S$ : état initial
	\item $A \subseteq S$ : ensemble des états acceptant
	\item $\Delta \subset Sx\times \sum \times \Gamma \times S \times 
		\Gamma^*$ : relation de transition (finie)
\end{itemize}

\begin{myprop}
	Tout comme NDFA, un PDA définit un ensemble récursif de mots (langage 
	récursif)
\end{myprop}

\paragraph{Convention :} 
\begin{itemize}
	\item Z est le symbole initial de la pile (pile vide)
	\item $\epsilon$ signifie qu’aucun symbole ne doit être lu pour cette 
		transition (symbole "vide")
	\item A, B / C : A est le symbole lu, B est le symbole au 
		sommet de la pile et C est ce qui va remplacer le 
		sommet de la pile (peut-être un symbole et B pour 
		rajouter, $\epsilon$ pour retirer le sommet de la pile, 
		ou juste B pour ne pas changer le sommet)
\end{itemize}

\begin{myprop}
	Certains ensembles récursifs ne peuvent pas être reconnus par un automate 
	à pile. Ex: L = ${a^n b^n a^n | n\geq 1}$
\end{myprop}

\begin{myprop}
	Les automates à pile sont plus puissants que les automates finis (ils 
	peuvent reconnaitre plus d'ensembles)
\end{myprop}

\begin{myprop}
	Ce n'est pas un modèle complet de la calculabilité donc par Hoare 
	Allison, l'interpréteur n'est pas calculable dans le modèle
\end{myprop}

% subsection automate_pile (end)

\subsection{Grammaires et modèles de calcul}
\label{sub:grammaires_et_mod_les_de_calcul}

\paragraph{Objectif :}
Définition d'un langage (ensemble de mots) et à partir de la grammaire on peut 
générer/dériver les mots du langage.

\paragraph{Utilisation :} Utilisé pour la définition de langage de 
programmation, pour l'analyse du langage naturel...

\paragraph{Composition du modèle :}

\begin{itemize}
	\item $\sum$ : alphabet
	\item éléments de $\sum$ sont des symboles terminaux
	\item autres symboles utilisés durant la dérivation : symboles non 
		terminaux (A,B, ..., <dig>,..
	\item S : point de départ de la dérivation (symbole non terminal)
\end{itemize}

\begin{mydef}
	On appelle un ensemble de règles de dérivation des règles de production
\end{mydef}

\begin{myexem}
	$\sum ={0,1,2}$ \\
	$S \rightarrow <Dig>$ \\
	$<Dig> \rightarrow D$ \\
	$D \rightarrow 0 | 1 |2 | \epsilon $ ($\epsilon$ ne signifie rien)
\end{myexem}
TODO Exemple littéraux real en Java

\begin{mydef}[Dériver] c'est appliquer des règles de la grammaire pour vérifier 
	si une chaîne de symbole appartient au langage (on part d'une chaîne de symbole 
	et on vérifie les règles sur celle-ci).
\end{mydef}

\begin{mydef}[Inférer] c'est une dérivation dans "le sens contraire", 
	c'est-à-dire, on part des règles de grammaire et on génère une chaîne 
	de symboles.
\end{mydef}

\begin{mydef}
	Un arbre syntaxique permet de représenter la dérivation, chaque noeud 
	correspond à un symbole terminal ou non. Et les arêtes correspondent à 
	l'application d'une règle. Il y a plusieurs noeuds enfants si la règle 
	"génère" plusieurs symboles.
\end{mydef}

\begin{myprop}
	On peut dériver de plusieurs façons équivalente, leftmost (on dérive 
	toujours le plus à gauche d'abord), rightmost (contraire de leftmost) 
	ou  aucun des deux
\end{myprop}

\subsubsection{Hiérarchie de Chomsky}
\label{ssub:hi_rarchie_de_chomsky}

Chomsky a défini 4 types de grammaires formelles. On peut les classer selon 
leur "puissance".

\begin{mydef}
	Une grammaire A est plus puissante qu'une B si on peut définir plus 
	de langage avec A qu'avec B
\end{mydef}

On peut aussi faire correspondre chaque type de grammaire avec un type de 
calcul permettant de reconnaitre un langage de cette grammaire.

\begin{tabular}{|c|c|c|}
	\hline	
	 Type & Type de grammaire & Modèle de calcul\\
	 \hline
	3 & régulière & Automate fini \\
	2 & hors contexte & Automate à pile \\
	1 & sensible au contexte & Machine de Turing à ruban fini \\
	0 & récursivement énumérable & Machine de Turing \\
	\hline
\end{tabular}

Chaque type de grammaire est définie par une règle de production $A\rightarrow 
B$. Mais, il y a des conditions différentes sur A et B selon le type de 
grammaire.
% subsubsection hi_rarchie_de_chomsky (end)

\subsubsection{Grammaires régulières}

\paragraph{Règle de production :} 
\begin{itemize}
	\item $A \rightarrow \omega B$
	\item $A \rightarrow \omega$
\end{itemize}

\paragraph{Conditions :}

\begin{itemize}
	\item  $\omega \in \sum^*$ c'est à dire $\omega$ est une chaîne de symbole non 
	terminal. 
	\item A et B ne peuvent être qu’ un symbole non terminal
\end{itemize}

\begin{myexem}
	$S \rightarrow abS$ \\
	$S \rightarrow \epsilon$ \\
	Cette grammaire définit différents langages, par exemple $L1 = 
	\{(ab)^n|n \geq 0\}$. Ce langage peut-être défini par une expression 
	régulière.
\end{myexem}


\subsubsection{Grammaires hors contexte}

Cette grammaire est importante, car il suffit de lui rajouter la portée des 
variables pour définir la syntaxe d'un langage.

\paragraph{Règle de production :} 
\begin{itemize}
	\item $A \rightarrow \beta$
\end{itemize}

\paragraph{Conditions :}

\begin{itemize}
	\item  $\beta$ est une chaîne de symbole composé de symboles terminaux
	       	ou non
	\item A ne peut être qu’ un symbole non terminal
\end{itemize}

\begin{myexem}
	$S \rightarrow aSb$ \\
	$S \rightarrow \epsilon$ \\
	Un langage défini par cette grammaire est par exemple $L1 = \{a^nb^n|n 
		\geq 0\}$
\end{myexem}

\subsubsection{Grammaires sensibles au contexte}

\paragraph{Règle de production :} 
\begin{itemize}
	\item $\alpha \rightarrow \beta$
\end{itemize}

\paragraph{Conditions :}

\begin{itemize}
	\item $\alpha$ et $\beta$ sont des chaînes de symboles composées de 
		symboles terminaux ou non. De plus, $\beta$ contient au moins 
		autant de symboles que $\alpha$.
\end{itemize}

\begin{myexem}
	$S \rightarrow aSBA$ \\
	$S \rightarrow abA$ \\
	$AB \rightarrow BA$ \\
	$bB \rightarrow bb$ \\
	$bA \rightarrow ba$ \\
	$aA \rightarrow aa$ \\
	Un langage défini par cette grammaire est par exemple $L1 =
	\{a^nb^na^n|n \geq 0\}$
\end{myexem}


\subsubsection{Grammaires sans restriction}

\paragraph{Règle de production :} 
\begin{itemize}
	\item $\alpha \rightarrow \beta$
\end{itemize}

\paragraph{Conditions :}

\begin{itemize}
	\item $\alpha$ et $\beta$ sont des chaînes de symboles composées de 
		symboles terminaux ou non.
\end{itemize}

\begin{myexem}
	Il y a donc moyen de créer des règles qui bouclent : \\
	$\alpha \rightarrow \beta$ \\
	$\beta \rightarrow \alpha$\\
\end{myexem}

\subsection{Machines de Turing}[Intérêt] Le modèle des machines de Turing est le modèle le plus 
simple, le plus élémentaire et le plus puissant possible. Il permet une 
définition précise de procédure, d'algorithme ou encore de calcul.

\paragraph{Composition "abstraite" :}

\begin{description}
	\item[Ruban] Suite de case potentiellement infinie (des 2 côtés), mais à 
		chaque moment, le ruban nécessaire est fini
	\item[Tête] Une seule tête, sur une case qui peut écrire et lire la 
		case sur laquelle elle est
	\item[Contrôle] Dirige les actions/opérations
\end{description}

\subsubsection{Contrôle}
\label{ssub:contr_le}
Le contrôleur est composé d'un nombre d'états fini dont un état initial et un 
final. Il contient un programme (des instructions)

\begin{mydef}[Une instruction] est sous la forme 
	$$<q,c> \rightarrow <new_q, Mouv, new_c>$$
	\begin{itemize}
		\item q : état courant
		\item c : symbole sous la tête de lecture
		\item $new_c$ : symbole à écrire sous la tête de lecture
		\item Mouv : G ou D, mouvement que la tête de lecture doit faire
		\item $new_q$ : le nouvel état
	\end{itemize}
\end{mydef}

% subsubsection contr_le (end)

\subsubsection{Modélisation}
Pour définir une machine de Turing, il faut :
\begin{itemize}
	\item $\sum$ : ensemble fini de symboles d'entrée
	\item $\Gamma$ : ensemble fini de symboles de ruban.
	\item $S$ : ensemble fini d'états
	\item $s_0 \in S$ : état initial
	\item $stop \in S$ : état arrêt
	\item $A \subseteq S$ : ensemble des états acceptant
	\item $\delta : Sx\times \times \Gamma \rightarrow S \times \{G,D\} 
	\times \Gamma$ : relation de transition (finie)
\end{itemize}
Il faut aussi que $\sum \subset \Gamma$ et que B $\in \Gamma$ mais que B 
$\notin \sum$

\begin{mydef}
		B correspond au symbole blanc
\end{mydef}

\subsubsection{Exécution}
Au départ il y a juste les données sur le ruban. Sur les autres cases, il y a le 
symbole B. La tête de lecture se trouve sur la première case. Tant que c'est 
possible, on applique des instructions. Il y a 2 cas possibles pour l'arrêt soit 
l'état devient stop. Soit il n'y a plus d'instruction applicable.

\paragraph{} Le résultat est le contenu du ruban à l'état-stop. Si la machine 
ne s'arrête pas sur l'état-stop alors il n'y a pas de résultat.

\begin{mydef}[T-calculable] Une fonction f est T-calculable s’ il existe une machine de Turing qui, 
	recevant comme donnée n'importe quel nombre entier x fourni tôt ou tard 
	comme résultat f(x) si celui-ci existe.
\end{mydef}

\begin{mydef}[T-récursif] Soit $A\subseteq \N$, A est T-récursif s’ il existe 
	une machine de Turing qui, recevant comme donnée n'importe quel nombre 
	naturel x, fourni tôt ou tard comme résultat : 
	\begin{tabular}{l}
		1 si $x\in A$ \\
		0 si $x\notin A$ \\
	\end{tabular}
\end{mydef}

\begin{mydef}[T-récursivement énumérable] Soit $A\subseteq \N$, A est 
	T-récursivement énumérable s’ il existe 
	une machine de Turing qui, recevant comme donnée n'importe quel nombre 
	naturel x, fourni tôt ou tard comme résultat : \\
	\begin{tabular}{l}
		1 si $x\in A$ \\
		si $x\notin A$ la machine s'arrête avec un état$\neq$ stop ou 
		alors, celle-ci boucle\\
	\end{tabular}
\end{mydef}

\subsubsection{Thèse de Church-Turing}
\begin{enumerate}
	\item Toute fonction T-calculable est calculable
	\item Toute fonction calculable est T-calculable
	\item Tout ensemble T-récursif est récursif
	\item Tout ensemble récursif est T-récursif
	\item Tout ensemble T-récursivement énumérable est récursivement 
		énumérable
	\item Tout ensemble récursivement énumérable est T-récursivement 
		énumérable
\end{enumerate}
Les points 1, 3 et 5 sont des théorèmes. Les autres sont des thèses.

\subsubsection{Extension du modèle}
On peut modifier le modèle pour changer sa puissance et son efficacité.

\begin{mydef}[Efficacité d'une MT] L'efficacité d'une MT se calcule en 
	fonction du nombre d'instructions à exécuter (on ne tient pas compte de 
	la taille d'un mot mémoire).
\end{mydef}

\paragraph{Changer les conventions}
On peut par exemple permettre de se déplacer de plusieurs cases à la fois ou 
encore de permettre plusieurs états stop.

\paragraph{Influence :} 
\begin{itemize}
	\item Même puissance
	\item Speedup linéaire (pour aller 20 cases à gauche on doit plus 
		exécuter 20 instructions se déplacer à gauche)
\end{itemize}

Réduire les symboles => binaire

\paragraph{Influence :} 
\begin{itemize}
	\item Même puissance
	\item Même efficacité, car même s’ il y a un facteur logarithmique en 
		calculabilité on le néglige
\end{itemize}

Limiter le nombre d'états, ça implique qu'il y a seulement un nombre fini de 
machines de Turing différentes.

\paragraph{Influence :} 
\begin{itemize}
	\item Moins puissant
\end{itemize}

\paragraph{Autres rubans}

Ruban unidirectionnel, c'est-à-dire limité d'un coté (à priori à gauche)/

\paragraph{Influence :} 
\begin{itemize}
	\item Même puissance
	\item Slowdown linéaire : il faut faire plus de déplacement, en 
		effet, avant les cases étaient numéroté 
		$-\inf,...-2,-1,0,1,2,...,\inf$, alors que maintenant
	       	$0,-1,1,-2,2,...,-\inf,\inf$ 
\end{itemize}

Ruban multicases, c'est-à-dire la tête lis plusieurs cases en parallèle. Ce qui 
implique que la taille de l'alphabet augmente.

\paragraph{Influence :} 
\begin{itemize}
	\item Même puissance
	\item Même efficacité
\end{itemize}

Plusieurs rubans c'est-à-dire la tête peut se déplacer dans des directions 
différentes d'un ruban à l'autre. On doit pour ça changer la relation de 
transition. Elle doit maintenant prendre plusieurs symboles et un état et 
retourner un état, plusieurs symboles à écrire et plusieurs directions différentes.
$$<s_1,s_2,...s_n>, E \  \rightarrow \ E', M_1, M_2,..., M_n, D_1, D_2,..., 
D_n$$
\paragraph{Influence :} 
\begin{itemize}
	\item Même puissance
	\item Même efficacité
\end{itemize}

\subsubsection{Machine de Turing non déterministe NDT}
Tout comme pour les automates non déterministes, on permet plusieurs 
transitions possibles pour une paire <état, symbole>. Ce qui implique qu'il y a 
plusieurs exécutions possibles.

\begin{myrem}
	On utilise les NDT uniquement pour décider un ensemble
\end{myrem}

\begin{myrem}
	Cette partie importante pour la partie concernant la complexité
\end{myrem}

\begin{mydef}[NDT-récursif] Soit $A\subseteq \N$, A est NDT-récursif s’ il 
	existe une ND-machine de Turing telle que lorsqu'elle reçoit comme 
	donnée n'importe quel nombre naturel x\\
	\begin{tabular}{l}
		Si $x\in A$, alors il existe une exécution fournissant tôt ou 
		tard comme résultat 1\\
		Si $x\notin A$, alors il existe une exécution fournissant tôt ou 
		tard comme résultat 0\\
	\end{tabular}
\end{mydef}

\begin{mydef}[NDT-récursivement énumérable] Soit $A\subseteq \N$, A est 
	NDT-récursivement énumérable s’ il 
	existe une ND-machine de Turing telle que lorsqu'elle reçoit comme 
	donnée n'importe quel nombre naturel x\\
	\begin{tabular}{l}
		Si $x\in A$, alors il existe une exécution fournissant tôt ou 
		tard comme résultat 1\\
		Si $x\notin A$, les exécutions possibles soit retourne un 
		nombre $\neq 1$ \\
		soit ne se termine pas ou encore s'arrête avec 
		un état $\neq$ stop\\
	\end{tabular}
\end{mydef}

\paragraph{Influence :} 
\begin{itemize}
	\item Même puissance, car il existe une machine de Turing qui interprète
	 les NDT 
	\item Speedup exponentielle, car on "descend" directement au bon endroit 
		dans l'arbre. Mais en comme en pratique on doit simuler 
		l'exécution non déterministe ça ne change rien.
\end{itemize}

\subsubsection{Machine de Turing avec Oracle}
On ajoute 3 états spéciaux : soit $A \subseteq \N$
\begin{itemize}
	\item $oracle_{ask}$ : demander si l'entier représenté à droite de la 
		tête de lecture appartient à l'ensemble A
	\item $oracle_{yes}$ : l'entier appartient à A
	\item $oracle_{no}$ :  l'entier n'appartient pas à A
\end{itemize}

\paragraph{Puissance :} Ça dépend de A car si A est récursif, ça n'apporte pas 
grand-chose, car on peut remplacer l'oracle par un programme qui décide A. Donc 
même puissance. Par contre si A n'est pas récursif, alors c'est un modèle plus 
puissant (on pourrait déterminer halt). Mais ce n’est pas possible d'exécuter un tel programme. 

\begin{myrem}
	Utilité : permets d'établir une hiérarchie parmi les problèmes 
	indécidables. Ça permet de dire et si K est récursif quels problèmes 
	seraient encore indécidable.
\end{myrem}

\subsubsection{Machine de Turing Universelle}

\paragraph{Objectif :} Construire une machine de Turing qui soit un 
interpréteur de machines de Turing

\begin{myrem}
	On définit un encodage de 0, 1 qui permet de représenter une MT
\end{myrem}

Une telle machine est possible à construire. Il faut 3 rubans:
\begin{itemize}
	\item codage de la MT à interpréter
	\item donnée
	\item résultat intermédiaire de l'interpréteur
\end{itemize}
% subsection machines_de_turing (end)

\subsection{Fonctions récursives}
\label{sub:fonction_r_cursives}
Ce modèle de calcul se base sur la définition mathématique de fonction. On va 
s'intéresser aux fonctions de $\N^k \ \rightarrow \ \N$.

\paragraph{} Il y a 2 grandes classes de fonctions récursives: 
\begin{itemize}
	\item Fonctions primitives récursives, on se limite aux fonctions totales 
		(équivalent au langage BLOOP)
	\item Fonction récursives, c'est un modèle complet, on peut calculer 
		toutes les fonctions calculables 
\end{itemize}

\paragraph{Fonctions de bases} Ce sont des fonctions qui vont être utilisées 
pour construire nos fonctions.

\begin{description}
	\item[Fonctions constantes] 
		\begin{tabular}{|l|}
			\hline
			a:$\N^0 \rightarrow \N$\\
			a() = a\\
			\hline
		\end{tabular}
	\item[Fonctions successeur] 
		\begin{tabular}{|l|}
			\hline
			s:$\N \rightarrow \N$\\
			s(n) = n + 1\\
			\hline
		\end{tabular}
	\item[Fonctions de projection] 
		\begin{tabular}{|l|}
			\hline
			$p^k_i: \N^k \rightarrow \N$\\
			$p^k_i(x_1,..,x_i,...x_k) = x_i$\\
			\hline
		\end{tabular}
\end{description}

Il existe aussi 2 "règles" importantes :
\paragraph{Composition}
\begin{tabular}{|l|}
	\hline
	$h_1, h_2,...,h_m: \N^k \rightarrow \N$\\
	$g: \N^m \rightarrow \N$\\
	$\stcomp{x} =x_1,...x_k$ \\
	$f(\overline{x} = 
	g(h_1(\overline{x}),h_i(\overline{x}),...,h_k(\overline{x}))$\\
	\hline
\end{tabular}

\paragraph{Récursion primitive}
\begin{tabular}{|l|}
	\hline
	$h: \N^{k+2} \rightarrow \N$\\
	$g: \N^k \rightarrow \N$\\
	$\stcomp{x} =x_1,...x_k$ \\
	$f(\overline{x}, 0) = g(\overline{x})$ (Cas de base)\\
	$f(\overline{x}, n+1) = 
	h(\overline{x},n, f(\overline{x}, n))$\\
	\hline
\end{tabular}

\begin{myrem}
	Lors de l'utilisation de la récursion primitive, il faut faire 
	attention. Le cas de base ne peut pas faire appel à $f$ et on passe 
	toujours de n+1 à n. Car, il ne peut pas y avoir de récursion infinie.
\end{myrem}

\subsubsection{Fonctions primitives récursives}
Ce modèle ne permet d'utiliser que les fonctions de base et les fonctions 
obtenues suite à l'application de composition ou de récursion primitive.

\begin{myprop}
	Les fonctions primitives récursives ne sont pas un modèle de complet de 
	la calculabilité. En effet, il ne peut pas y avoir de récursion 
	infinie. Donc on ne peut calculer avec ce modèle que des fonctions 
	totales calculables. De plus, on sait par Hoare Allison que comme ce 
	n'est pas un modèle complet, sont interpréteur n'est pas calculable 
	dans le modèle.
\end{myprop}

\begin{myexem}
	La fonction d'Ackermann est une fonction calculable \textbf{non} 
	primitive récursive :
	\begin{align}
		ack(0,m) &= m+1 \\
		ack(n+1,0) &= ack(n+1)\\
		ack(n+1,m+1) &= ack(n, ack(n+1,m))
	\end{align}
	Cette fonction à une croissance plus rapide que n'importe quelle fonction 
	primitive récursive
\end{myexem}


\subsubsection{Fonctions récursives}
\label{ssub:fonctions_r_cursives}
On va étendre les fonctions primitives récursives en ajoutant une règle :

\paragraph{Minimisation}
\begin{tabular}{|l|}
	\hline
	$h: \N^{k+1} \rightarrow \N$\\
	$f: \N^{k} \rightarrow \N$\\
	$\stcomp{x} =x_1,...x_k$ \\
	$f(\overline{x}) = \mu_n (h(\overline(x), n) =0)$\\
	$\mu_n$ est le plus petit n tel que $h(\overline(x), n) =0$ \\
	\hline
\end{tabular}

\begin{myprop}
	Les fonctions récursives sont un modèle complet de la calculabilité. 
	Toute fonction calculable est une fonction récursive et vice versa.
\end{myprop}
% subsection fonction_r_cursives (end)

\subsection{Lambda calcul}
\label{sub:lambda_calcul}
\begin{myrem}
	C'est encore un modèle pas très intuitif. Je pense que c'est important 
	de refaire l'exercice sur le vrai ou faux en lambda calcul ou encore la 
	représentation des entiers dans le cours. Mais c'est un modèle complet 
	et qui contient la base de la programmation fonctionnelle.
\end{myrem}

\begin{mydef}[Symboles de base] Soit une variable : a,b,c,...y,z,... ou un 
	symbole spécial : $\lambda$, (,)
\end{mydef}

\begin{mydef}[Expression lambda] est
	\begin{itemize}
		\item une variable
		\item $\lambda xB$ si B est une expression lambda et que x est 
			une variable ($\lambda x$ correspond à la définition 
			d'une variable \textbf{liée}) \\
			$\lambda xB$ correspond à la définition d'une fonction 
			à un paramètre, x.
		\item (FA) si F et A sont des expressions lambda. On dit que F 
			est l'opérateur et A est l'opérande. Ça représente 
			l'application de F à A.
	\end{itemize}
\end{mydef}

\begin{mydef}[Variable liée] est une variable qui suit un $\lambda$ ou qui 
	apparait dans M et qu'on a $\lambda xM$. 
\end{mydef}

\begin{mydef}[Variable libre] est une variable qui n'est pas liée.
\end{mydef}

\subsubsection{Réduction}

\paragraph{Objectif :} appliquer les fonctions (opérateur) à un opérande, 
jusqu'à ce qu'il n'y ait plus de fonction à appliquer. On obtient alors une 
forme réduite.

\begin{mydef}[Application de fonction] Si on a une expression lambda (FA) où 
	F est une fonction $\lambda xB$. On remplace toutes les occurrences liées 
	de x dans B par A.
\end{mydef}

\begin{myrem}
	Il faut faire attention, car lorsqu'on réduit une expression on ne peut 
	pas introduire de conflit de nom donc il faut renommer les variables.
\end{myrem}

\begin{myrem}
	Il est possible d'avoir des réductions infinies par exemple : 
	$(\lambda x\ (xx)\ \lambda x \ (xx)) \ \rightarrow \ (\lambda x\ (xx) \  
\lambda x \ (xx))$
\end{myrem}

\begin{myrem}
	Il est important de voir qu'il y a plusieurs façon de réduire, ça 
	dépend de l'ordre dans lequel on applique les réductions.
\end{myrem}

\begin{myprop}
	Une expression lambda est non définie si peut importe le choix de 
	réduction, on n’arrive pas à une forme réduite.
\end{myprop}

\begin{mytheo}[Church-Rosser] Si 2 séquences de réductions d'une expression 
	lambda conduisent ) une forme réduite, alors les expressions obtenues 
	sont équivalentes.
\end{mytheo}

\begin{myprop}
	Si une forme réduite existe, le choix de réduire l'expression la plus à 
	gauche amène toujours à une forme réduite. (Donc, privilégier la 
	réduction la plus à gauche)
\end{myprop}

\begin{myrem}
	Il existe 2 types de réduction la plus à gauche, la moins imbriquée 
	(semblable au passage par nom en programmation) et la plus imbriquée 
	(semblable au passage par valeur).
\end{myrem}
% subsection lambda_calcul (end)
% section mod_le_de_la_calculabilit_ (end)

\section{Analyse de la thèse de Church-Turing}
\label{sec:analyse_de_la_th_se_de_church_turing}
Dans ce chapitre on va principalement voir ce qu'est un bon formalisme.

\subsection{Fondement de la thèse}
\label{sub:fondement_de_la_th_se}
La forme originale ne contient que 2 parties :
\begin{enumerate}
	\item Toute fonction calculable par une MT est effectivement calculable
	\item Toute fonction effectivement calculable est effectivement 
		calculable par une MT 
\end{enumerate}
La partie 1 est démontrée et la 2 est supposée vraie. 
On la suppose vraie, car on a des évidences heuristiques (il y a eu beaucoup 
d'essais pour trouver une fonction qui ne respectait pas la thèse) et qu'on a montré 
l'équivalence entre tous les formalismes créé à ce jour (on a montré que toute 
machine constructible par la mécanique de Newton ne calcul que des fonctions 
calculables). 
% subsection fondement_de_la_th_se (end)

\subsection{Formalismes de la calculabilité}
\label{sub:formalismes_de_la_calculabilit_}
On va se posé la question de qu'est-ce qui fait un bon formalisme de la 
calculabilité. La réponse est un formalisme qui vérifie les fondements de la 
thèse ... Plus précisément on va étudier des caractéristiques (des propriétés) 
nécessaire et suffisante pour avoir un bon modèle de la calculabilité.

\paragraph{} Dans ce chapitre, on va considérer un formalisme de la 
calculabilité D.

\paragraph{Caractéristiques} 
\begin{description}
	\item[SD] : Soundness des descriptions
	\item[CD] : Complétude des descriptions
	\item[SA] : Soundness algorithmique
	\item[CA] : Complétude algorithmique
	\item[U] : Description universelle
	\item[S] : Propriété S-m-n affaiblie
\end{description}

\begin{myrem}
	Les propriétés sur les descriptions peuvent être vues comme il existe. On 
	dit qu'il existe une description.
	Alors que celles sur les algorithmes sont plus concrètes en disant qu'on 
	est capable d'écrire l'algorithme. On dit qu'il existe une description 
	\textbf{exécutable sur des données}.
\end{myrem}

\paragraph{Caractérisiques plus en détails}
\paragraph{Caractéristiques} 
\begin{description}
	\item[SD] : Toute fonction D-calculable est calculable (première partie 
		de la thèse de Turing)
	\item[CD] : Toute fonction Calculable est D-calculable (deuxième partie 
		de la thèse de Turing)
	\item[SA] : L'interpréteur de D est calculable (on peut exécuté une 
		description de programme de D)
	\item[CA] : L'interpréteur d'un autre formalisme qui respecte la 
		propriété SA est 
		D-calculable (on peut par exemple exécuter un programme Java 
		dans le formalisme D). On peut aussi dire qu'il existe une 
		compilateur qui étant donné un programme $p$ dans un formalisme 
		respectant SA produit une description de programme $d \in D$. 
		Et que $p$ et $d$ calcule la même fonction.
	\item[U] : L'interpréteur de D est D-calculable (sinon on sait par 
		Hoare Allison que ce n'est pas un formalisme complet).
	\item[S] : il existe un transformateur de programme calculable, qui 
		recevant comme entrée un programme D à 2 arguments et une valeur 
		x fournit comme résultat un programme D' tel que D'(y) calcul 
		la même chose que D(x,y)
\end{description}
Un bon formalisme de la calculabilité possède toutes ces propriétés. Mais il 
suffit d'en montrer certaines car certaines propriétés en entrainent d'autres.

\begin{myprop}
	SA $\Rightarrow$ SD, car si on peut trouver une description exécutable 
	donc celle-ci existe.
\end{myprop}

\begin{myprop}
	CA $\Rightarrow$ CD, car si on a un compilateur qui compile un programme 
	de P en une description dans D. Alors un programme de P est calculable dans D.
\end{myprop}

\begin{myprop}
	SD et U $\Rightarrow$ SA car si on sait qu'il existe une description et 
qu'on a un interpréteur de D, D-calculable. Alors la description est exécutable.
\end{myprop}

\begin{myprop}
	CD et S $\Rightarrow$ CA, car par CD on sait que ... (A compléter)
\end{myprop}

Un bon formalisme doit donc posséder soit SA et CA ou soit SD, CD, U et S ou 
soit SA, CD et S ou encore CA, SD et U., Car
\begin{itemize}
	\item SA et CA $\iff$ SD, CD, U et S
	\item SA ,CD et S $\iff$ SD, CA et U
\end{itemize}
% su section formalismes_de_la_calculabilité_ (end)

\subsection{Techniques de preuve}
\label{sub:techniques_de_preuve}

Pour prouver qu'un problème est non calculable, on peut utiliser :
\begin{itemize}
	\item Le théorème de Rice
	\item La démonstration directe de la non-calculabilité par 
		diagonalisation ou par preuve par l'absurde. 
		\textbf{A priori le plus dur!} C'est plus pratique de réutiliser les problèmes pour 
		lesquels on a déjà montré la non-calculabilité.
	\item La méthode de réduction
\end{itemize}
% subsection techniques_de_preuve (end)

\subsection{Aspects non couverts par la Calculabilité}
\label{sub:aspects_non_couvert_par_la_calculabilit_}
La calculabilité se limite au calcul de fonction or certains problèmes de la vie 
de tous les jours ne correspondent pas à une fonction.

\begin{myexem}
	Système d'exploitation
\end{myexem}

\begin{myexem}
	Système de réservation aérienne
\end{myexem}

\begin{myexem}
	Certains problèmes utilisent des caractéristiques de l'environnement comme 
	des données en provenance de sonde.
\end{myexem}
% subsection aspects_non_couvert_par_la_calculabilit_ (end)

\subsection{Au-delà de la calculabilité}
\label{sub:au_del_de_la_calculabilit_}
Est-ce possible d'imaginer un modèle plus puissant que les modèles qu'on a 
aujourd'hui? Est-ce que les humains sont "plus puissants" que les machines dans 
le sens ou il pourrait calculer des fonctions non calculables?

\paragraph{} Ce sont des questions qui font débat. Certain ne veulent même pas 
poser la deuxième question c'est-à-dire est-ce que H-calculable = calculable.

\begin{mydef}[H-calculable]
	Une fonction est H-calculable si un être humain calculant cette 
	fonction peut décrire à un autre humain sa méthode de calcul et que 
	l'autre humain est capable de calculer cette fonction.
\end{mydef}

\paragraph{} A la question les machines pensent-elles? Turing a proposé un 
raisonnement : 
\begin{itemize}
	\item \textbf{Hypothèse :} les machines pensent.
	\item Si on ne peut réfuter l'hypothèse alors celle-ci est vraie
	\item Envisager toutes les objections (théologique, émotions, 
		mathématiques...) et toutes les réfuter.
\end{itemize}

% subsection au_del_de_la_calculabilit_ (end)
% section analyse_de_la_t_se_de_chu ch_Turin (end)

\section{Complexité}
\label{sec:complexit_}
Lors de l'étude de la complexité, on ne va considérer que la borne supérieure 
(notation big O). De plus, on ne va considérer que les fonctions totales et 
donc la décision d'ensemble récursif. 
En effet, si la fonction n'est pas totale, l'algorithme peut boucler. 
Donc on ne sait pas étudier l'efficacité.

\begin{mydef}[Complexité d'un problème] Complexité de l'algorithme le 
	\textbf{plus efficace} résolvant ce problème.
\end{mydef}

\begin{mydef}[Problème pratiquement faisable]
	S’ il existe un algorithme de complexité polynomial qui résolvant ce 
	problème. Alors, celui-ci est pratiquement faisable.
\end{mydef}

\begin{mydef}[Problème intrinsèquement complexe]
	S’ il n'existe pas un algorithme de complexité polynomial qui résolvant ce 
	problème. Alors, celui-ci est intrinsèquement complexe.
\end{mydef}

\begin{myrem}
	Quelle est la différence entre intrinsèquement complexe et pratiquement 
	infaisable?
\end{myrem}

\subsection{Influence du modèle de calcul}
\label{sub:influence_du_mod_le_de_calcul}
Si un algorithme est de complexité polynomiale dans un modèle complet alors il sera 
polynomial dans un autre modèle de calcul. Il y aura juste un facteur 
polynomial entre les deux. Car, il existe un compilateur du premier modèle vers 
le second qui a une complexité polynomiale.
% subsection influence_du_mod_le_de_calcul (end)

\subsection{Influence de la représentation des données}
\label{sub:influence_de_la_repr_sentation_des_donn_es}
Le choix de représentation de donnée induit une variation polynomiale du temps 
d'exécution et de l'espace.

\begin{myrem}
	Certains problèmes sont intrinsèquement complexes juste pour certaines 
	données (simplex). Et celles-ci sont souvent des cas particuliers et peuvent 
	rencontrées en pratique.
\end{myrem}
% subsection influence_de_la_repr_sentation_des_donn_es (end)

% section complexit_ (end)

\section{Classes de complexité}
\label{sec:classes_de_complexit_}
On va se "limiter" au problème de décision.

\begin{myrem}
	on ne se limite pas vraiment car on 
	peut facilement transformer un problème en un problème de décision.
\end{myrem}

\subsection{Réduction}
\label{sub:r_duction}

\paragraph{Objectif :} Déduire un algorithme pour un problème P' à partir d'un 
algorithme P. Ça permet :
\begin{itemize}
	\item prouver la calculabilité/non calculabilité
	\item d'analyser le degré de non-calculabilité
	\item déduire la complexité
	\item d'analyser le degré de complexité
\end{itemize}

\begin{mydef}[Relation de réductibilité]
	$A \leq B$ : A réductible à B. Cette relation induit des classes 
	d'équivalence. On peut comprendre ça comme A est plus "simple" que B.
\end{mydef}

Il existe plusieurs méthodes de réduction qui ont des propriétés différentes.
Mais dans ce cours on va en étudier 
que 3 :
\begin{itemize}
	\item réduction algorithmique
	\item réduction fonctionnelle 
	\item réduction polynomiale
\end{itemize}

\begin{mydef}[A-complet]
	Soit A une classe de problème, un problème E est A-complet
	\textbf{par rapport} à une relation de réduction $\leq$ si 
	\begin{enumerate}
		\item $E \in A$
		\item $\forall B \in A \ : \ B \leq E$
	\end{enumerate}
\end{mydef}

\begin{myrem}
	Ce qui signifie que ce problème appartient à la classe de problème et 
	est A-difficile.	
\end{myrem}

\begin{mydef}[A-difficile]
	Soit A une classe de problème, un problème E est A difficile
	\textbf{par rapport} à une relation de réduction $\leq$ si 
	\begin{enumerate}
		\item $\forall B \in A \ : \ B \leq E$
	\end{enumerate}
\end{mydef}
	
\begin{myrem}
	Donc n'importe quel problème de A peut être réduit au problème E. 
	Attention E n'appartient pas nécessairement à A.
\end{myrem}


\subsubsection{Réduction algorithmique}
Ce type de réduction n'apporte aucune information au niveau de la complexité car, on 
peut répéter autant de fois qu'on veut l'algorithme qui décide B. On peut aussi 
faire un calcul avec une complexité très grande en plus d'utiliser B.

\begin{mydef}[Réduction algorithmique]
	Un ensemble A est algorithmiquement réductible à un ensemble B 
	($A\leq_a B$) si en supposant B récursif, A est récursif.
\end{mydef}

\begin{myrem}
	C'est à dire en supposant qu'on connait un algorithme qui décide B, on 
	peut construire un algorithme qui décide A.
\end{myrem}

\begin{myprop}
	Si $A \leq_a B$ et B récursif, alors A récursif (par définition)
\end{myprop}

\begin{myprop}
	Si $A \leq_a B$ et A non récursif, alors B non récursif (par définition)
\end{myprop}

\begin{myprop}
	$A \leq_a \stcomp{A}$
\end{myprop}

\begin{myprop}
	$A \leq_a B \ \iff \ \stcomp{A} \leq_a \stcomp{B}$
\end{myprop}

\begin{myprop}
	Si $A$ est récursif alors peut importe le B, $A \leq B$
\end{myprop}

\begin{myprop}
	Si $A \leq_a B$ et B récursivement énumérable alors A n'est pas 
	\textbf{nécessairement récursivement énumérable}
\end{myprop}

\subsubsection{Réduction fonctionnelle}
Ce type de réduction n'apporte aucune information au niveau de la complexité
car, ça dépend de la complexité de la fonction f.

\begin{mydef}[Réduction fonctionnelle]
	Un ensemble A est fonctionnellement réductible à un ensemble B 
	($A\leq_f B$) s’ il existe une fonction \textbf{totale calculable} f 
	telle que 
	\[ a\in A \ \iff \ f(a) \in B \]
\end{mydef}

\begin{myrem}
	Donc pour décider si $a\in A$ il suffit de calculer $f(a)$ et décider si 
	$f(a) \in B$. Pour trouver une réduction fonctionnelle, il faut trouver 
	une fonction qui transforme un problème de A en un problème de B.
\end{myrem}

\begin{myprop}
	Si $A \leq_f B$ et B récursif, alors A récursif (par définition)
\end{myprop}

\begin{myprop}
	Si $A \leq_f B$ et A non récursif, alors B non récursif (par définition)
\end{myprop}

\begin{myprop}
	$A \leq_f B \ \iff \ \stcomp{A} \leq_f \stcomp{B}$
\end{myprop}

\begin{myprop}
	Si $A$ est récursif alors peut importe le B, $A \leq B$
\end{myprop}

\begin{myprop}
	Si $A \leq_f B$ et B récursivement énumérable alors A est
	\textbf{nécessairement récursivement énumérable}
\end{myprop}

\begin{myprop}
	$A\leq_f \Rightarrow A\leq_a$ (Attention ce n'est pas toujours vrai 
	dans l'autre sens)
\end{myprop}

\subsubsection{Différence entre $\leq_a$ et $\leq_f$}
La principale différence, c'est que $A \leq_a B$ est plus du point de vue de la 
calculabilité. On s'intéresse au fait que ça soit possible, on peut utiliser 
autant de fois que l'on veut le fait que B soit récursif. \\
Alors que $A \leq_f B$ est plus du point de vue de la complexité. On est 
obligé d'utiliser un certain schéma d'algorithme :

\begin{lstlisting}
input a
a2 := f(a)
if a2 in B then 1
else 0
\end{lstlisting}

On est donc limité à utiliser qu'une fois le test $f(a) \in B$ \textbf{en 
	derniers lieux}.

\subsection{Modèles de calcul}
D'habitude, on utilise les machines de Turing pour avoir une définition précise 
de la complexité. Mais c'est peu intuitif et on s'intéresse aux frontières. Or la 
différence de complexité entre différents modèles est un facteur polynomial 
(c'est une thèse) ce qui n'a pas d'influence sur les frontières.

\subsection{Classe de complexité}

\paragraph{Classes basées sur le modèle déterministe}
\begin{mydef}[DTIME(f)]
	Famille des ensembles récursifs pouvant être décidés par un programme 
	Java de complexité temporelle O(f)
\end{mydef}

\begin{mydef}[DSPACE(f)]
	Famille des ensembles récursifs pouvant être décidés par un programme 
	Java de complexité spatiale O(f)
\end{mydef}

\paragraph{Classes basées sur le modèle non déterministe}
\begin{mydef}[NDTIME(f)]
	Famille des ensembles récursifs pouvant être décidé par un programme 
	non déterministe Java de complexité temporelle O(f)
\end{mydef}

\begin{myrem}
	On considère juste la complexité de la branche d'exécution la plus
	longue. Donc toutes les branches sont finies.	
\end{myrem}

\begin{mydef}[NDSPACE(f)]
	Famille des ensembles récursifs pouvant être décidé par un programme 
	non déterministe Java de complexité spatiale O(f)
\end{mydef}

\begin{mydef}[Classe P]
	\[ P = \cup _{i \leq 0} DTIME(n_i)\]
	Famille des ensembles récursifs pouvant être décidés par un programme
	Java de complexité polynomiale.
\end{mydef}

\begin{myrem}
	Les classes ne dépendent pas du modèle de calcul
\end{myrem}

\begin{mydef}[Classe NP]
	\[ NP = \cup _{i \leq 0} NTIME(n_i)\]
	Famille des ensembles récursifs pouvant être décidés par un programme
	Java non déterministe de complexité polynomiale.
\end{mydef}

\begin{myrem}
	Si on savait faire du non-déterminisme, on aurait une complexité polynomiale,
	mais pour le moment on ne peut que le simuler donc on a une complexité
	exponentielle.
\end{myrem}

\subsection{Relations entre les classes de complexité}
\label{sub:relations_entre_les_classes_de_complexit_}

\paragraph{Déterministe vs non-déterministe}
\begin{myprop}
	$A \in NTIME(f) \Rightarrow A \in DTIME(c^f)$ \\
	En effet, f est la profondeur maximale de l'arbre donc si on simule le
	ND alors on doit faire un bfs dans un arbre de profondeur f.
\end{myprop}

\begin{myprop}
	$A \in NSPACE(f) \Rightarrow A \in DSPACE(c^f)$ \\
	En effet, c'est une borne sur le nombre de noeuds d'un graphe de
	profondeur f.
\end{myprop}

\paragraph{Time vs Space}
\begin{myprop}
	$A \in DTIME(f) \Rightarrow A \in DSPACE(f)$ \\
	En effet, le programme ne peut utiliser qu’ au maximum un emplacement
	mémoire par instruction. Donc, l'espace utilisé est limité par le
	nombre d'instructions.
\end{myprop}

\begin{myprop}
	$A \in NTIME(f) \Rightarrow A \in NSPACE(f)$ \\
	C'est la même chose que pour le cas déterministe (propriété précédente).
\end{myprop}

\begin{myprop}
	$A \in DSPACE(f) \Rightarrow A \in DTIME(c_f)$ \\
	On sait que le programme se termine donc il trouve la réponse. Or il y
	a une combinaison de la mémoire qui est la réponse. Donc le programme
	ne peut pas générer plus que le nombre de combinaison possible de la
	mémoire sinon il passerait la réponse.
\end{myprop}

\begin{myprop}
	$A \in NSPACE(f) \Rightarrow A \in NTIME(c_f)$ \\
	C'est la même chose que pour le cas déterministe (propriété précédente).
\end{myprop}

\paragraph{Hiérarchie de complexité}
On peut prouver qu'il existe pire qu'une complexité exponentielle.

\subsection{NP-complétude}
La question fondamentale de la complexité est, s’ il existe un algorithme
non déterministe polynomial, existe-t-il un algorithme déterministe polynomial
résolvant ce même problème. C'est-à-dire, est-ce que P = NP. On sait que $P
\subseteq NP$ mais on a pas encore montré si oui ou non $NP\subseteq P$.

\paragraph{} Pour démontrer ça, on essaye de montrer qu'un élément de NP, le
plus difficile, est dans P. On choisit un élément qui soit NP-complet par
rapport à une relation de réduction. Ainsi, si on y arrive, ça implique que
tous les autres éléments de NP sont dans P aussi.

\paragraph{} La question est maintenant de choisir la relation de réduction.
Les 2 relations de réduction définie précédemment ne suffisent pas. Car, ces
réductions ne permettent pas d'affirmer quelque chose sur la complexité. On
introduit donc une nouvelle réduction, la réduction polynomiale.

\begin{mydef}[Réduction polynomiale]
	Un ensemble A est polynomialement réductible ) un ensemble B, $A \leq
	_p B$ s’ il existe une fonction \textbf{totale calculable} f de
	\textbf{complexité temporelle polynomiale} telle que 
	\[a\in A \ \Leftrightarrow \ f(a)\in B \]
\end{mydef}

\begin{myrem}
	On ajoute à la réduction fonctionnelle, une contrainte de complexité
	sur la fonction f. Cette réduction nous permet donc de tirer des
	conclusions sur la complexité de A sachant la complexité de B.
\end{myrem}

\begin{myprop}
	\[ A \leq_p B \text{ et } B\in P \Rightarrow A\in P \]
	Ce qui est logique étant donné qu'on à la complexité de f qui est
	polynomiale + la complexité de la décision de B qui est aussi
	polynomial.
\end{myprop}

\begin{myprop}
	\[ A \leq_p B \text{ et } B\in NP \Rightarrow A\in NP \]
	Ce qui est logique étant donné qu'on à la complexité de f qui est
	polynomiale + la complexité de la décision de B qui est non déterministe
	polynomiale.
\end{myprop}


\begin{mydef}[NP-complétude]
	Un problème E est NP-complet (par rapport à $\leq_p$) si :
	\begin{enumerate}
		\item $E\in NP$
		\item $\forall B \in NP$ : $B\leq_p E$
	\end{enumerate}
\end{mydef}

\begin{myprop}
	\[ E \leq_p B \text{ et } B\in NP \Rightarrow \text{B est NP-complet} \]
	Ce qui est logique puisque ça veut dire que B est NP-difficile et dans
	NP.
\end{myprop}

TODO schéma sur les classes de problèmes

\paragraph{} On va maintenant essayer de trouver des problèmes NP-complet et de
trouver des propriétés intéressantes sur P.

\subsubsection{Problème de décision}
On va définir différemment la classe NP. On va considérer des problèmes de
décision. Pour un ensemble à ça consiste à dire si oui ou non une donnée x
appartient à A. On peut voir ça comme un prédicat. Par exemple SAT(x) : la
formule x est-elle satisfaisable?

\paragraph{Redéfinition de P et NP} en problème de décision.

\begin{mydef}[Classe P]
	La classe P est la classe des problèmes de décision pouvant être
	calculés par un algorithme polynomial.
\end{mydef}

\begin{mydef}[Classe NP]
	La classe NP est la classe des problèmes de décision A(x) pouvant
	s'exprimer sous la forme $\exists y \ B(x,y)$ tel que :
	\begin{itemize}
		\item $B(x,y) \in P$ (Il est donc facile de vérifier une
			solution)
		\item le domaine de y est fini (taille polynomiale en x
		       	et peut être généré, de manière non déterministe, en 
			un temps polynomial
	\end{itemize}
\end{mydef}

\begin{myrem}
	On peut se représenter ça comme si le non-déterminisme permettait
       	de générer tout les y "en même temps" ou 
	que le non-déterminisme choisissait le bon y.
\end{myrem}

\begin{mydef}[Calcul d'un problème NP]
	Pour décider A(x)
	\begin{enumerate}
		\item calculer y (de manière non déterministe)
		\item déterminer B(x,y)
	\end{enumerate}
\end{mydef}

\subsection{Théorème de Cook : SAT est NP-complet}
Pour pouvoir trouver des problèmes NP-complet en les réduisant par rapport à
un problème NP-complet, il faut trouver un premier problème NP-complet. 
\paragraph{} On va montrer que SAT est NP-complet en 2 parties :
\begin{enumerate}
	\item $SAT \in NP$
	\item $\forall B \in NP \ : \  B\leq_p SAT $
\end{enumerate}

\subsubsection{Le problème SAT}
Le problème SAT(x) est de décider si la formule propositionnelle x est 
satisfaisable ou non. C'est à dire est-ce que $x\in SAT$.

\paragraph{} La longueur d'une formule x est $O(n\log n)$. Où n est le nombre
d'occurrences des variables. Ça se justifie par le fait qu'en utilisant un codage
d'Huffman, le code pour une variable prendra $\log n$ (c'est important pour
définir la complexité du problème).

\subsubsection{$SAT \in NP$}
Il existe un programme ND polynomiale capable de décider si $x\in SAT$. On pose
que m est le nombre de variables de x et n est le nombre d'occurrences de
variable ($m\leq x$). Étape de l'algorithme avec leur complexité :
\begin{itemize}
	\item  Générer une séquence de m valeurs logiques de façon
		non déterministique : $O(m)$
	\item  Substituer les occurrences des variables par leur valeur : $O(n
		\log n)$ 
	\item Évaluer l'expression : Complexité polynomiale par une technique
		de réduction.
\end{itemize}

\subsubsection{$\forall B \in NP \ : \  B\leq_p SAT $}
Comme $B \in NP$, on a une NDMT qui décide B en un temps polynomial p(n). On va
montrer qu'on sait transformer en un temps polynomial la NDMT par rapport à n
en une formule propositionnelle et que cette formule à une longueur qui dépend 
de p(n) ($O(p(n))$ symboles). Ce qui prouve que $B \leq_p SAT$.

\paragraph{Idée de la transformation} Il me semble qu'on ne doit pas la connaitre
pour l'examen. Mais l'idée est de représenter le ruban comme un tableau de
variables booléennes (chaque ligne représente le ruban à un instant), 
même chose pour les états, le curseur, l'alphabet,...


\subsection{Quelques problèmes NP-complets}
\begin{itemize}
	\item Problème du circuit hamiltonien HC (trouver un chemin qui passe
		une seule fois par tous les sommets)
	\item Problème du voyageur de commerce TS (trouver un chemin qui relie
		tous les sommets et de longueur $\leq$ B)
	\item Chemin le plus long entre 2 sommets dans un graphe
	\item 3SAT (forme conjonctive avec 3 variables par clause)
	\item Programmai on entière (simplex)
	\item ...
\end{itemize}

% section classes_de_complexit_ (end)
\end{document}
